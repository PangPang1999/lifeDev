## 12- 显示平台图标

> 简述：在游戏卡片上显示各游戏平台图标。涉及解析 API 中平台数据结构，创建`PlatformIconList`组件，使用`react-icons`库，并将平台标识符（slug）映射到具体图标。

**知识树**

1.  API 数据结构 (`parent_platforms`):
    - `parent_platforms` 是一个数组，其元素是对象。
    - 每个对象包含一个 `platform` 属性，该属性的值才是真正的平台对象（包含`id`, `name`, `slug`）。
2.  接口更新 (`Game.ts` 或 `useGames.ts`):
    - 为 `Game` 接口添加 `parent_platforms` 属性。
    - 定义 `Platform` 接口: `{ id: number; name: string; slug: string; }`。
    - `parent_platforms` 类型: `{ platform: Platform }[]`。
3.  组件创建 (`PlatformIconList.tsx`):
    - Props: `platforms: Platform[]`。
    - 职责：接收平台对象数组并渲染对应的图标。
4.  React Icons 库:
    - 安装: `npm install react-icons`.
    - 导入特定图标集 (如 `react-icons/fa` for Font Awesome, `react-icons/md` for Material Design, etc.)。
5.  图标映射 (`iconMap`):
    - 创建一个对象，键为平台 `slug` (小写文本标识符，如 `pc`, `playstation`)，值为对应的 React Icon 组件 (如 `FaWindows`, `FaPlaystation`)。
    - `iconMap` 类型注解: `[key: string]: IconType` (其中 `IconType` 从 `react-icons` 导入)，以解决 TypeScript 索引签名问题。
6.  Chakra UI `Icon` 组件:
    - 使用 `as` prop 动态渲染 `iconMap` 中查找到的图标组件。
7.  Chakra UI `HStack` 组件: 用于水平排列平台图标。
8.  样式:
    - 图标颜色: `gray.500` (或其他中性色，避免视觉干扰)。
    - 图标列表与标题间距: `HStack` 的 `marginY`。

**代码示例**

1.  接口定义 (通常在 `hooks/useGames.ts` 或单独的类型文件中):

    ```ts
    export interface Platform {
      id: number;
      name: string;
      slug: string;
    }

    export interface Game {
      // ...其他属性
      parent_platforms: { platform: Platform }[];
    }
    ```

2.  `components/PlatformIconList.tsx`:

    ```tsx
    import { HStack, Icon } from '@chakra-ui/react';
    import { Platform } from '../hooks/useGames'; // 假设 Platform 接口从此导出
    import { IconType } from 'react-icons';
    import {
      FaWindows, FaPlaystation, FaXbox, FaApple, FaLinux, FaAndroid,
    } from 'react-icons/fa';
    import { MdPhoneIphone } from 'react-icons/md';
    import { SiNintendo } from 'react-icons/si';
    import { BsGlobe } from 'react-icons/bs';

    interface Props {
      platforms: Platform[];
    }

    const PlatformIconList = ({ platforms }: Props) => {
      const iconMap: { [key: string]: IconType } = { // 键为 slug
        pc: FaWindows,
        playstation: FaPlaystation,
        xbox: FaXbox,
        nintendo: SiNintendo,
        mac: FaApple,
        linux: FaLinux,
        android: FaAndroid,
        ios: MdPhoneIphone, // 对应 API slug 'ios'
        web: BsGlobe,
      };

      return (
        <HStack marginY={1}> {/* 调整了 marginY */}
          {platforms.map((platform) => (
            <Icon key={platform.id} as={iconMap[platform.slug]} color="gray.500" />
          ))}
        </HStack>
      );
    };

    export default PlatformIconList;
    ```

3.  `components/GameCard.tsx` 中使用:

    ```tsx
    // ... imports ...
    import PlatformIconList from './PlatformIconList';
    import { Game } from '../hooks/useGames'; // 确保 Game 接口包含 parent_platforms

    interface Props {
      game: Game;
    }

    const GameCard = ({ game }: Props) => {
      return (
        <Card>
          {/* ... Image ... */}
          <CardBody>
            <Heading fontSize="2xl">{game.name}</Heading>
            <PlatformIconList platforms={game.parent_platforms.map(p => p.platform)} />
            {/* ... CriticScore (下一节) ... */}
          </CardBody>
        </Card>
      );
    };
    ```

    - 注意 `game.parent_platforms.map(p => p.platform)` 将 API 返回的结构转换为 `Platform[]`。

## 13- 显示评价分数

> 简述：在游戏卡片上添加一个徽章，用于显示游戏的媒体评价分数（Metacritic score）。创建`CriticScore`组件，使用 Chakra UI 的`Badge`组件，并根据分数高低动态改变徽章颜色。

**知识树**

1.  API 数据: 游戏对象中包含 `metacritic` 属性，其值为数字类型的分数。
2.  接口更新 (`Game.ts` 或 `useGames.ts`):
    - 为 `Game` 接口添加 `metacritic: number` 属性。
3.  组件创建 (`CriticScore.tsx`):
    - Props: `score: number`。
    - 职责：接收分数并以徽章形式展示。
4.  Chakra UI `Badge` 组件:
    - 用于显示分数文本。
    - 样式属性: `fontSize`, `paddingX`, `borderRadius`。
    - `colorScheme`: 根据分数动态设置。例如：高分 ( > 75) 为 `green`，中等分数 ( > 60) 为 `yellow`，低分为默认或不设置。
5.  布局 (`GameCard.tsx`):
    - 使用 `HStack` 包裹游戏标题 (`Heading`) 和 `CriticScore` 组件。
    - 设置 `HStack` 的 `justifyContent="space-between"` 使标题居左，分数徽章居右。

**代码示例**

1.  `components/CriticScore.tsx`:

    ```tsx
    import { Badge } from '@chakra-ui/react';

    interface Props {
      score: number;
    }

    const CriticScore = ({ score }: Props) => {
      let color = score > 75 ? 'green' : score > 60 ? 'yellow' : '';
      return (
        <Badge colorScheme={color} fontSize="14px" paddingX={2} borderRadius="4px">
          {score}
        </Badge>
      );
    };

    export default CriticScore;
    ```

2.  `components/GameCard.tsx` 中集成:

    ```tsx
    // ... imports ...
    import CriticScore from './CriticScore';
    import { HStack } from '@chakra-ui/react'; // 确保导入 HStack

    // ... Game 接口应包含 metacritic ...

    const GameCard = ({ game }: Props) => {
      return (
        <Card>
          {/* ... Image ... */}
          <CardBody>
            <HStack justifyContent="space-between" marginBottom={3}> {/* 新增 HStack */}
              <Heading fontSize="2xl">{game.name}</Heading>
              <CriticScore score={game.metacritic} />
            </HStack>
            <PlatformIconList platforms={game.parent_platforms.map(p => p.platform)} />
          </CardBody>
        </Card>
      );
    };
    ```

## 14- 获取优化图像

> 简述：实现图像 URL 修改功能，从 API 获取经过裁剪优化的图像版本，以提高页面加载速度。为此创建一个工具函数。

**知识树**

1.  API 图像裁剪: RAWG API 支持在图像 URL 的 `media/` 路径后添加 `crop/宽度/高度/` 参数来获取裁剪后的图像。例如 `.../media/crop/600/400/games/...`。
2.  工具函数 (`src/services/image-url.ts`):
    - 函数签名: `getCroppedImageUrl(url: string): string`。
    - 逻辑:
        - 检查 `url` 是否为空或无效，若是则返回占位符图像 URL 或原始 URL。
        - 定位原始 URL 中 `media/` 字符串的位置。
        - 在 `media/` 之后、原文件名之前插入 `crop/600/400/` (或其他期望的裁剪尺寸)。
3.  使用 (`GameCard.tsx`):
    - 在渲染游戏背景图 (`game.background_image`) 时，调用 `getCroppedImageUrl` 函数处理 URL。

**代码示例**

1.  `src/services/image-url.ts`:

    ```ts
    const getCroppedImageUrl = (url: string) => {
      if (!url) return ''; // 或返回一个默认的占位符图片URL
      const target = 'media/';
      const index = url.indexOf(target) + target.length;
      return url.slice(0, index) + 'crop/600/400/' + url.slice(index);
    };

    export default getCroppedImageUrl;
    ```

2.  `components/GameCard.tsx` 中使用:

    ```tsx
    // ... imports ...
    import getCroppedImageUrl from '../services/image-url'; // 导入工具函数

    // ...

    const GameCard = ({ game }: Props) => {
      return (
        <Card /* ... */ >
          <Image src={getCroppedImageUrl(game.background_image)} /> {/* 使用工具函数 */}
          <CardBody>
            {/* ... */}
          </CardBody>
        </Card>
      );
    };
    ```

## 15- 使用加载骨架改善用户体验

> 简述：在游戏数据加载期间，为游戏卡片显示加载骨架屏（Loading Skeletons），以改善用户等待体验。创建`GameCardSkeleton`组件，并在`useGames`钩子中管理加载状态。

**知识树**

1.  加载状态管理 (`useGames.ts`):
    - 添加 `isLoading` 状态变量 (布尔类型)，初始值为 `false` (或 `true` 如果初始即加载)。
    - 在发起 API 请求前，设置 `isLoading = true`。
    - 在请求成功 (`.then()`) 或失败 (`.catch()`) 后，设置 `isLoading = false`。
    - 从钩子中返回 `isLoading`状态。
2.  骨架屏组件创建 (`GameCardSkeleton.tsx`):
    - 结构模仿 `GameCard` 组件。
    - 使用 Chakra UI 的 `Skeleton` 组件替代 `Image`。
        - 设置 `Skeleton` 的 `height` (例如 `'200px'`) 以匹配图片大致高度。
    - 使用 Chakra UI 的 `SkeletonText` 组件替代 `Heading` 和其他文本内容。
        - `SkeletonText` 的 `noOfLines` 属性控制显示的骨架线条数。
    - 整体包裹在 Chakra UI `Card` 和 `CardBody` 中，与 `GameCard` 结构一致。
3.  条件渲染逻辑 (`GameGrid.tsx`):
    - 从 `useGames` 钩子获取 `isLoading` 状态。
    - 创建一个数字数组 (例如 `skeletons = [1, 2, 3, 4, 5, 6]`) 用于迭代生成多个骨架屏。数组长度可根据每页预期显示数量设定。
    - 当 `isLoading` 为 `true` 时，遍历 `skeletons` 数组并渲染相应数量的 `GameCardSkeleton` 组件。
    - 当 `isLoading` 为 `false` 时，渲染实际的 `GameCard` 组件。
4.  样式一致性 (初始阶段):
    - 为 `GameCard` 和 `GameCardSkeleton` 内的 `Card` 组件应用相同的 `borderRadius` 和 `overflow="hidden"`，以确保视觉统一和避免布局抖动。（后续章节会重构此部分重复样式）。
    - （视频中提到宽度问题，但后续通过容器解决，此处骨架屏本身不需要固定宽度，它会填充其容器）。

**代码示例**

1.  `hooks/useGames.ts` (或通用 `useData.ts`) 中更新加载状态:

    ```ts
    // 在 useData.ts 或 useGames.ts
    // ...
    const [isLoading, setLoading] = useState(false); // 初始为 false，或 true

    useEffect(() => {
      setLoading(true); // 请求开始前
      apiClient
        .get<FetchResponse<T>>(endpoint, { signal: controller.signal, ...requestConfig })
        .then((res) => {
          setData(res.data.results);
          setLoading(false); // 请求成功后
        })
        .catch((err) => {
          if (err instanceof CanceledError) return;
          setError(err.message);
          setLoading(false); // 请求失败后
        });
      // ...
      return { data, error, isLoading }; // 返回 isLoading
    }, deps ? [...deps] : []);
    ```

2.  `components/GameCardSkeleton.tsx`:

    ```tsx
    import { Card, CardBody, Skeleton, SkeletonText } from '@chakra-ui/react';

    const GameCardSkeleton = () => {
      return (
        <Card>
          <Skeleton height="200px" /> {/* 模拟图片 */}
          <CardBody>
            <SkeletonText mt="4" noOfLines={3} spacing="4" /> {/* 模拟文本 */}
          </CardBody>
        </Card>
      );
    };

    export default GameCardSkeleton;
    ```

3.  `components/GameGrid.tsx` 中条件渲染:

    ```tsx
    // ... imports ...
    import GameCardSkeleton from './GameCardSkeleton';
    // ... useGames() 或 useData() 返回 isLoading ...

    const GameGrid = () => {
      const { data: games, error, isLoading } = useGames(); // 假设 useGames 返回 isLoading
      const skeletons = [1, 2, 3, 4, 5, 6]; // 用于生成骨架屏的数量

      // ... error handling ...

      return (
        <SimpleGrid /* ... */ >
          {isLoading &&
            skeletons.map((skeleton) => (
              <GameCardSkeleton key={skeleton} />
            ))}
          {!isLoading &&
            games.map((game) => (
                <GameCard key={game.id} game={game} />
            ))}
        </SimpleGrid>
      );
    };
    ```

## 16- 重构-移除重复样式

> 简述：通过创建一个新的`GameCardContainer`组件来封装`GameCard`和`GameCardSkeleton`共有的外部容器样式（如`borderRadius`, `overflow`），以消除代码重复并提高可维护性。

**知识树**

1.  问题识别: `GameCard.tsx` 和 `GameCardSkeleton.tsx` 中的 `Card` 组件应用了相同的 `borderRadius` 和 `overflow="hidden"` 样式，导致代码重复。
2.  解决方案: 创建一个专门的容器组件 `GameCardContainer.tsx`。
3.  `GameCardContainer.tsx` 实现:
    - 使用 Chakra UI 的 `Box` 组件作为基础。`Box` 默认渲染为 `div`。
    - 将共享的样式（如 `borderRadius="10px"`, `overflow="hidden"`，以及视频中后续移除的 `width`）应用到这个 `Box` 组件上。
    - 接收 `children` prop (类型为 `React.ReactNode`) 并在 `Box` 内部渲染它们。
4.  应用容器组件 (`GameGrid.tsx`):
    - 在 `GameGrid.tsx` 中，分别用 `GameCardContainer` 包裹 `GameCard` 和 `GameCardSkeleton`。
    - 从 `GameCard.tsx` 和 `GameCardSkeleton.tsx` 内部的 `Card` 组件上移除这些被提取的共享样式。
5.  VS Code 快捷操作: "Wrap with abbreviation" (Mac: `Shift+Command+P`, Windows: `Shift+Control+P`) 可以快速用指定标签或组件包裹选中代码。

**代码示例**

1.  `components/GameCardContainer.tsx`:

    ```tsx
    import { Box, BoxProps } from '@chakra-ui/react'; // BoxProps 可选，用于更强类型
    import { ReactNode } from 'react';

    interface Props {
      children: ReactNode;
    }

    const GameCardContainer = ({ children }: Props) => {
      return (
        <Box borderRadius="10px" overflow="hidden"> {/* 共享样式 */}
          {children}
        </Box>
      );
    };

    export default GameCardContainer;
    ```

2.  `components/GameGrid.tsx` 中使用 `GameCardContainer`:

    ```tsx
    // ... imports ...
    import GameCardContainer from './GameCardContainer';

    const GameGrid = () => {
      const { data: games, error, isLoading } = useGames();
      const skeletons = [1, 2, 3, 4, 5, 6];

      return (
        <SimpleGrid /* ... */ >
          {isLoading &&
            skeletons.map((skeleton) => (
              <GameCardContainer key={skeleton}>
                <GameCardSkeleton />
              </GameCardContainer>
            ))}
          {!isLoading &&
            games.map((game) => (
              <GameCardContainer key={game.id}>
                <GameCard game={game} />
              </GameCardContainer>
            ))}
        </SimpleGrid>
      );
    };
    ```

3.  `components/GameCard.tsx` (移除共享样式):

    ```tsx
    // Card 组件不再需要 borderRadius 和 overflow
    const GameCard = ({ game }: Props) => {
      return (
        <Card> {/* 移除了 borderRadius, overflow */}
          <Image src={getCroppedImageUrl(game.background_image)} />
          {/* ... CardBody ... */}
        </Card>
      );
    };
    ```

4.  `components/GameCardSkeleton.tsx` (移除共享样式):
    ```tsx
    // Card 组件不再需要 borderRadius 和 overflow
    const GameCardSkeleton = () => {
      return (
        <Card> {/* 移除了 borderRadius, overflow */}
          <Skeleton height="200px" />
          {/* ... CardBody ... */}
        </Card>
      );
    };
    ```

## 17- 获取类型数据

> 简述：从 RAWG API 获取游戏类型（Genres）列表。创建`GenreList`组件用于显示类型，并为此创建一个新的自定义钩子`useGenres`，其初始实现与`useGames`钩子类似，为后续的通用化重构做准备。

**知识树**

1.  API 端点: `/genres` 用于获取游戏类型数据。其响应结构与 `/games` 类似，包含 `count`, `next`, `previous`, `results` (类型对象数组)。
2.  接口定义 (`Genre`):
    - 至少包含 `id: number` 和 `name: string`。后续会根据需要添加 `image_background` 等属性。
3.  自定义钩子 (`hooks/useGenres.ts`):
    - 初始阶段：可以复制 `useGames.ts` (或已重构的 `useData.ts` 的早期版本) 的代码作为模板。
    - 状态变量: `genres` (类型为 `Genre[]`), `error` (string), `isLoading` (boolean)。
    - `useEffect` 钩子:
        - 使用 `apiClient` 从 `/genres` 端点获取数据。
        - 处理成功和错误情况，更新相应状态。
        - 包含请求取消逻辑 (`AbortController`)。
    - 定义 `FetchGenresResponse` 接口: `{ count: number; results: Genre[]; }`。
    - 返回 `{ genres, error, isLoading }`。
4.  组件创建 (`components/GenreList.tsx`):
    - 使用 `useGenres` 钩子获取类型数据、错误信息和加载状态。
    - 初始渲染：简单地使用 `ul` 和 `li` 标签显示类型名称 (`genre.name`)。
5.  集成到主应用 (`App.tsx`):
    - 将 `GenreList` 组件放置在侧边栏区域 (例如 `GridItem` 的 `area="aside"`)。
6.  代码重复的识别: 明确 `useGames` 和 `useGenres` 之间存在大量重复逻辑，为下一节创建通用数据获取钩子埋下伏笔。

**代码示例**

1.  接口定义 (可放在 `hooks/useGenres.ts` 或共享类型文件):

    ```ts
    export interface Genre {
      id: number;
      name: string;
      // image_background: string; // 后续会添加
    }

    interface FetchGenresResponse {
      count: number;
      results: Genre[];
    }
    ```

2.  `hooks/useGenres.ts` (初始版本，未通用化前):

    ```ts
    import { useEffect, useState } from 'react';
    import apiClient from '../services/api-client';
    import { CanceledError } from 'axios';

    // Genre 和 FetchGenresResponse 接口如上定义

    const useGenres = () => {
      const [genres, setGenres] = useState<Genre[]>([]);
      const [error, setError] = useState('');
      const [isLoading, setLoading] = useState(false);

      useEffect(() => {
        const controller = new AbortController();
        setLoading(true);
        apiClient
          .get<FetchGenresResponse>('/genres', { signal: controller.signal })
          .then((res) => {
            setGenres(res.data.results);
            setLoading(false);
          })
          .catch((err) => {
            if (err instanceof CanceledError) return;
            setError(err.message);
            setLoading(false);
          });

        return () => controller.abort();
      }, []);

      return { genres, error, isLoading };
    };

    export default useGenres;
    ```

3.  `components/GenreList.tsx` (初始版本):

    ```tsx
    import useGenres from '../hooks/useGenres';

    const GenreList = () => {
      const { genres, error, isLoading } = useGenres();

      if (error) return <p>{error}</p>; // 简单错误处理
      if (isLoading) return <p>Loading genres...</p>; // 简单加载提示

      return (
        <ul>
          {genres.map((genre) => (
            <li key={genre.id}>{genre.name}</li>
          ))}
        </ul>
      );
    };

    export default GenreList;
    ```

4.  `App.tsx` 中集成:

    ```tsx
    // ... imports ...
    import GenreList from './components/GenreList';

    function App() {
      return (
        <Grid
          templateAreas={{
            base: `"nav" "main"`,
            lg: `"nav nav" "aside main"`,
          }}
          // ... 其他 Grid 属性 ...
        >
          {/* ... Nav GridItem ... */}
          <Show above="lg">
            <GridItem area="aside" /* paddingX="5px" 后续添加 */ >
              <GenreList />
            </GridItem>
          </Show>
          {/* ... Main GridItem ... */}
        </Grid>
      );
    }
    ```

## 18- 创建通用数据获取钩子

> 简述：通过创建一个名为`useData<T>`的泛型自定义钩子，来重构并统一`useGames`和`useGenres`中的数据获取逻辑，从而消除代码重复，提高代码的复用性和可维护性。

**知识树**

1.  问题识别: `useGames` 和 `useGenres` 钩子在数据获取、状态管理（加载、错误）、请求取消等方面存在大量重复代码。
2.  解决方案: 创建一个通用的、可接收泛型参数的自定义钩子 `useData.ts`。
3.  `useData<T>(endpoint: string, requestConfig?: AxiosRequestConfig, deps?: any[])`:
    - 泛型参数 `T`: 代表期望获取的数据项的类型 (例如 `Game` 或 `Genre`)。
    - 参数 `endpoint: string`: API 请求的目标端点 (例如 `"/games"` 或 `"/genres"`)。
    - 可选参数 `requestConfig?: AxiosRequestConfig`: 允许传递额外的 Axios 请求配置 (例如用于发送查询参数)。
    - 可选参数 `deps?: any[]`: `useEffect`的依赖项数组，当依赖项变化时重新获取数据。
    - 内部状态: `data: T[]`, `error: string`, `isLoading: boolean`。
    - 泛型响应接口 `FetchResponse<T>`: `{ count: number; results: T[]; }`。
    - `useEffect`:
        - 使用传入的 `endpoint` 和 `requestConfig` 发起 API 请求。
        - 处理数据、错误和加载状态的更新。
        - 包含请求取消逻辑 (`AbortController`)。
        - 依赖项数组包含 `endpoint` 和 `deps` (如果提供)。
    - 返回: `{ data, error, isLoading }`。
4.  重构 `useGenres.ts`:
    - 移除内部的数据获取逻辑。
    - 调用 `useData<Genre>('/genres')` 并返回其结果。
    - 继续导出 `Genre` 接口，供 `GenreList` 组件使用。
5.  重构 `useGames.ts`:
    - 移除内部的数据获取逻辑。
    - 调用 `useData<Game>('/games')` 并返回其结果。
    - 继续导出 `Game` (及相关的 `Platform`) 接口。
6.  组件适配:
    - `GenreList.tsx`: 继续使用 `useGenres` 钩子，但其内部已是 `useData` 的调用。注意从钩子返回的对象中，原先的 `genres` 属性现在是 `data`，需要相应调整解构赋值或使用。
    - `GameGrid.tsx`: 类似地，原先的 `games` 属性现在是 `data`。

**代码示例**

1.  `hooks/useData.ts`:

    ```ts
    import { useEffect, useState } from 'react';
    import apiClient from '../services/api-client';
    import { AxiosRequestConfig, CanceledError } from 'axios';

    interface FetchResponse<T> {
      count: number;
      results: T[];
    }

    const useData = <T>(endpoint: string, requestConfig?: AxiosRequestConfig, deps?: any[]) => {
      const [data, setData] = useState<T[]>([]);
      const [error, setError] = useState('');
      const [isLoading, setLoading] = useState(false);

      useEffect(() => {
        const controller = new AbortController();
        setLoading(true);
        apiClient
          .get<FetchResponse<T>>(endpoint, { signal: controller.signal, ...requestConfig })
          .then((res) => {
            setData(res.data.results);
            setLoading(false);
          })
          .catch((err) => {
            if (err instanceof CanceledError) return;
            setError(err.message);
            setLoading(false);
          });

        return () => controller.abort();
      }, deps ? [...deps] : []); // 依赖项数组

      return { data, error, isLoading };
    };

    export default useData;
    ```

2.  重构后的 `hooks/useGenres.ts`:

    ```ts
    import useData from './useData';

    export interface Genre { // 确保 Genre 接口已定义或导入
      id: number;
      name: string;
      image_background: string; // 为下一节准备
    }

    const useGenres = () => useData<Genre>('/genres');

    export default useGenres;
    ```

3.  重构后的 `hooks/useGames.ts`:

    ```ts
    import useData from './useData';
    import { Platform } from './useGenres'; // 假设 Platform 移至 useGenres 或共享文件

    export interface Game { // 确保 Game 接口已定义或导入
      id: number;
      name: string;
      background_image: string;
      parent_platforms: { platform: Platform }[];
      metacritic: number;
    }

    const useGames = () => useData<Game>('/games');

    export default useGames;
    ```

4.  `components/GenreList.tsx` (适配 `data` 属性):

    ```tsx
    import useGenres, { Genre } from '../hooks/useGenres'; // 导入 Genre 类型

    const GenreList = () => {
      const { data: genres, error, isLoading } = useGenres(); // 解构 data 并重命名为 genres

      // ...
      return (
        <ul>
          {genres.map((genre: Genre) => ( // 明确 genre 类型
            <li key={genre.id}>{genre.name}</li>
          ))}
        </ul>
      );
    };
    ```

5.  `components/GameGrid.tsx` (适配 `data` 属性):

    ```tsx
    import useGames, { Game } from '../hooks/useGames'; // 导入 Game 类型

    const GameGrid = () => {
      const { data: games, error, isLoading } = useGames(); // 解构 data 并重命名为 games

      // ...
      // games.map((game: Game) => ( ... ))
    };
    ```

## 19- 显示类型列表

> 简述：改进`GenreList`组件，使其能够显示游戏类型的图片和名称。调整侧边栏和主游戏网格的布局，以适应新的侧边栏内容并优化整体响应式表现。

**知识树**

1.  API 数据更新: 游戏类型对象 (`Genre`) 包含 `image_background` 属性，值为图片的 URL。
2.  接口更新 (`Genre` 接口，通常在 `hooks/useGenres.ts` 或 `hooks/useData.ts` 相关类型定义中):
    - 为 `Genre` 接口添加 `image_background: string` 属性。
3.  `GenreList.tsx` 组件增强:
    - 使用 Chakra UI `List` 和 `ListItem` 替代原生 `ul` 和 `li`，以获得更好的样式控制（如移除默认列表标记）。
    - 在每个 `ListItem` 内部使用 `HStack` 来水平排列类型图片和名称。
    - Chakra UI `Image` 组件:
        - `src`: 使用 `getCroppedImageUrl(genre.image_background)` 获取裁剪后的图片。
        - `boxSize`: 设置图片大小 (例如 `"32px"`)。
        - `borderRadius`: 设置图片圆角 (例如 `"8px"`)。
        - `objectFit="cover"`: 确保图片在指定尺寸内良好显示，不变形。
    - Chakra UI `Text` 组件:
        - 显示 `genre.name`。
        - `fontSize`: 调整字体大小 (例如 `"lg"`)。
    - `ListItem` 样式: `paddingY` (例如 `"5px"`) 增加垂直方向的间距。
4.  应用布局调整 (`App.tsx`):
    - 侧边栏容器 (`GridItem area="aside"`):
        - 添加 `paddingX` (例如 `"10px"`) 为侧边栏内容提供水平内边距。
    - 主网格 (`Grid`) `templateColumns` 属性:
        - `base: "1fr"`: 在小屏幕上，单列布局，主内容区占满可用宽度。
        - `lg: "200px 1fr"`: 在大屏幕 (`lg` 及以上) 上，侧边栏固定宽度 (例如 `200px`)，主内容区 (`1fr`)占据剩余空间。这确保侧边栏不会过宽或过窄。
5.  `GameCardContainer.tsx` 重构:
    - 移除之前可能为对齐骨架屏而添加的固定 `width` 样式。现在由于父级 `SimpleGrid` 和 `Grid` 的列宽定义，卡片容器应能自适应填充其分配到的空间。
6.  `GameGrid.tsx` (`SimpleGrid` 组件):
    - 调整 `spacing` 属性 (例如改为 `3` 或 `4`) 以优化卡片间的间距，因为卡片宽度现在是动态的。
7.  响应式布局验证: 在不同设备尺寸（手机、平板、桌面）下检查布局是否按预期工作，特别是侧边栏和主内容区的宽度分配。
8.  固定宽度移除的解释:
    - 之前为 `GameCardContainer` 设置固定宽度是为了在侧边栏宽度不确定时，确保 `GameCard` 和 `GameCardSkeleton` 宽度一致。
    - 现在 `App.tsx` 中的 `Grid` 为侧边栏 (`aside`) 定义了固定宽度 (在大屏幕上)，主内容区 (`main`) 的宽度也因此变得可预测。`SimpleGrid` 会将其列均匀分配到主内容区的可用宽度中。
    - 因此，`GameCardContainer` 不再需要固定宽度，它可以自然地伸展以填充 `SimpleGrid` 的列。这使得布局更具响应性和灵活性。
9.  `getCroppedImageUrl` 的限制: API 可能仅支持特定的裁剪尺寸，并非任意值都有效。

**代码示例**

1.  `hooks/useGenres.ts` (或相关类型文件) - 更新 `Genre` 接口:

    ```ts
    export interface Genre {
      id: number;
      name: string;
      image_background: string; // 添加此属性
    }
    ```

2.  `components/GenreList.tsx` (增强版):

    ```tsx
    import { HStack, Image, List, ListItem, Text } from '@chakra-ui/react';
    import useGenres, { Genre } from '../hooks/useGenres';
    import getCroppedImageUrl from '../services/image-url';
    // Spinner 和 Error 处理见下一节

    const GenreList = () => {
      const { data: genres, isLoading, error } = useGenres();

      if (error) return null; // 简单处理，下一节改进
      if (isLoading) return <Text>Loading...</Text>; // 简单处理，下一节改进

      return (
        <List>
          {genres.map((genre) => (
            <ListItem key={genre.id} paddingY="5px">
              <HStack>
                <Image
                  boxSize="32px"
                  borderRadius={8}
                  objectFit="cover" // 确保图片不变形
                  src={getCroppedImageUrl(genre.image_background)}
                  alt={genre.name}
                />
                <Text fontSize="lg">{genre.name}</Text>
              </HStack>
            </ListItem>
          ))}
        </List>
      );
    };

    export default GenreList;
    ```

3.  `App.tsx` - 布局调整:

    ```tsx
    function App() {
      return (
        <Grid
          templateAreas={{
            base: `"nav" "main"`,
            lg: `"nav nav" "aside main"`,
          }}
          templateColumns={{ // 定义列宽
            base: '1fr', // 小屏幕单列
            lg: '200px 1fr', // 大屏幕：侧边栏200px，主内容区占剩余
          }}
        >
          {/* ... Nav GridItem ... */}
          <Show above="lg">
            <GridItem area="aside" paddingX={5}> {/* 为侧边栏添加水平内边距 */}
              <GenreList />
            </GridItem>
          </Show>
          <GridItem area="main">
            <GameGrid />
          </GridItem>
        </Grid>
      );
    }
    ```

4.  `components/GameCardContainer.tsx` - 移除固定宽度 (如果之前有):

    ```tsx
    const GameCardContainer = ({ children }: Props) => {
      return (
        // 确保这里没有写死的 width 属性
        <Box borderRadius="10px" overflow="hidden">
          {children}
        </Box>
      );
    };
    ```

5.  `components/GameGrid.tsx` - 调整 `SimpleGrid` 间距:
    ```tsx
    const GameGrid = () => {
      // ...
      return (
        <SimpleGrid
          columns={{ sm: 1, md: 2, lg: 3, xl: 4 }} // 根据主内容区宽度调整
          spacing={3} // 调整间距
          padding="10px"
        >
          {/* ... GameCardContainer 和 GameCard/GameCardSkeleton ... */}
        </SimpleGrid>
      );
    };
    ```

## 20- 显示加载指示器

> 简述：在`GenreList`组件中，当游戏类型数据正在从 API 获取时，显示一个加载指示器（Spinner）。同时，处理错误状态，在发生错误时不在侧边栏渲染任何内容。

**知识树**

1.  加载状态处理 (`GenreList.tsx`):
    - 从 `useGenres` (或其内部调用的 `useData`) 钩子获取 `isLoading` 布尔状态。
    - 当 `isLoading` 为 `true` 时，渲染 Chakra UI 的 `Spinner` 组件。这提供了一个视觉反馈，表明正在进行后台操作。
2.  错误状态处理 (`GenreList.tsx`):
    - 从 `useGenres` 钩子获取 `error` 状态 (通常是一个错误消息字符串或空字符串)。
    - 当 `error` 存在 (即非空字符串) 时，组件返回 `null`。这意味着如果获取类型数据失败，侧边栏的类型列表部分将不显示任何内容，避免在页面多个部分显示分散的错误信息。
3.  替代方案:
    - 加载状态也可以用骨架屏（Skeletons）表示，但此处选择 `Spinner` 以展示不同的加载指示方式。
4.  错误模拟:
    - 可以通过临时修改 `useGenres` 钩子内部的 API 端点 (例如，在 `'/genres'` 后添加一个无效字符 `x`) 来手动触发错误，以测试错误处理逻辑。

**代码示例**

1.  `components/GenreList.tsx` (包含 Spinner 和错误处理):

    ```tsx
    import { HStack, Image, List, ListItem, Spinner, Text } from '@chakra-ui/react'; // 导入 Spinner
    import useGenres, { Genre } from '../hooks/useGenres';
    import getCroppedImageUrl from '../services/image-url';

    const GenreList = () => {
      const { data: genres, isLoading, error } = useGenres();

      if (error) return null; // 如果有错误，不渲染任何内容

      if (isLoading) return <Spinner />; // 如果正在加载，显示 Spinner

      return (
        <List>
          {genres.map((genre) => (
            <ListItem key={genre.id} paddingY="5px">
              <HStack>
                <Image
                  boxSize="32px"
                  borderRadius={8}
                  objectFit="cover"
                  src={getCroppedImageUrl(genre.image_background)}
                  alt={genre.name}
                />
                <Text fontSize="lg">{genre.name}</Text>
              </HStack>
            </ListItem>
          ))}
        </List>
      );
    };

    export default GenreList;
    ```

## 21- 按类型筛选游戏

> 简述：实现点击游戏类型后，游戏网格仅显示该类型的游戏。涉及状态提升、props 回调、修改自定义钩子以接受和处理筛选参数，并更新`useEffect`的依赖项以在筛选条件变化时重新获取数据。

**知识树**

1.  状态提升 (State Lifting):
    - 当多个子组件需要共享或影响同一状态时，该状态应提升到它们最近的共同父组件中管理。
    - `GenreList` 和 `GameGrid` 的共同父组件是 `App`。
    - 在 `App` 组件中定义 `selectedGenre: Genre | null` 状态。
2.  子组件通知父组件 (Props Callback):
    - `GenreList` 组件:
        - 添加 `onSelectGenre: (genre: Genre) => void` prop。
        - 将类型名称从 `Text` 改为 `Button` (Chakra UI `Button` 的 `variant="link"` 样式使其看起来像链接)。
        - 点击类型按钮时，调用 `onSelectGenre(genre)` 将选中的类型对象传递给父组件。
    - `App` 组件:
        - 传递 `(genre) => setSelectedGenre(genre)` 给 `GenreList` 的 `onSelectGenre` prop。
3.  父组件传递状态给子组件 (Props):
    - `App` 组件将 `selectedGenre` 状态作为 prop 传递给 `GameGrid` 组件。
4.  `GameGrid` 组件适配:
    - 添加 `selectedGenre: Genre | null` prop。
    - 将 `selectedGenre` 传递给 `useGames` (或 `useData`) 钩子。
5.  自定义钩子 (`useGames` 或 `useData`) 修改:
    - `useGames` (或 `useData` 的特定调用处):
        - 接收 `selectedGenre: Genre | null` 参数。
        - 在调用 `useData` (或直接调用 `apiClient`) 时，将 `selectedGenre.id` 作为查询参数 `genres` 传递。
        - API 文档指出 `genres` 参数可以是 ID 或 slug，此处使用 ID。
        - 使用可选链 (`selectedGenre?.id`) 处理 `selectedGenre` 可能为 `null` 的情况。
    - `useData` 钩子 (`hooks/useData.ts`):
        - 第二个参数修改为可选的 `requestConfig?: AxiosRequestConfig`，用于传递 Axios 的请求配置对象 (包含 `params`)。
        - 第三个参数修改为可选的 `deps?: any[]`，作为 `useEffect` 的依赖项数组。
        - 在 `apiClient.get` 调用中，合并 `signal` 和传入的 `requestConfig`。
        - `useEffect` 的依赖项数组现在是 `deps ? [...deps] : []`。如果 `deps` 未提供，则行为与之前空数组一致（仅首次渲染时执行）。
6.  `useEffect` 依赖项更新:
    - 在 `useGames` (或 `useData` 的调用处) 调用 `useData` 时，将 `[selectedGenre?.id]` 作为 `deps` 参数传递。这确保当 `selectedGenre` 的 ID 变化时，`useEffect` 会重新执行，从而获取筛选后的游戏数据。
7.  React `key` Prop 修复:
    - 确保在列表渲染 (如 `map` 函数) 中，为每个直接子元素提供唯一的 `key` prop。视频中修复了 `GameGrid` 中 `GameCardContainer` 和 `PlatformIconList` 中图标的 `key` 问题。

**代码示例**

1.  `App.tsx` (状态管理与传递):

    ```tsx
    import { Genre } from './hooks/useGenres'; // 或从 useData 导出的类型
    import { useState } from 'react';

    function App() {
      const [selectedGenre, setSelectedGenre] = useState<Genre | null>(null);

      return (
        <Grid /* ... */ >
          <Show above="lg">
            <GridItem area="aside" paddingX={5}>
              <GenreList
                selectedGenre={selectedGenre} // 为高亮显示 (下一节)
                onSelectGenre={(genre) => setSelectedGenre(genre)}
              />
            </GridItem>
          </Show>
          <GridItem area="main">
            <GameGrid selectedGenre={selectedGenre} />
          </GridItem>
        </Grid>
      );
    }
    ```

2.  `components/GenreList.tsx` (按钮化与回调):

    ```tsx
    import { Button, /* ...其他导入 */ } from '@chakra-ui/react';
    import { Genre } from '../hooks/useGenres';

    interface Props {
      selectedGenre: Genre | null; // 为高亮显示 (下一节)
      onSelectGenre: (genre: Genre) => void;
    }

    const GenreList = ({ selectedGenre, onSelectGenre }: Props) => {
      const { data: genres, isLoading, error } = useGenres();
      // ... isLoading, error handling ...
      return (
        <List>
          {genres.map((genre) => (
            <ListItem key={genre.id} paddingY="5px">
              <HStack>
                {/* ... Image ... */}
                <Button
                  variant="link"
                  fontSize="lg"
                  onClick={() => onSelectGenre(genre)}
                  // fontWeight (下一节)
                >
                  {genre.name}
                </Button>
              </HStack>
            </ListItem>
          ))}
        </List>
      );
    };
    ```

3.  `components/GameGrid.tsx` (接收 prop):

    ```tsx
    import { Genre } from '../hooks/useGenres';

    interface Props {
      selectedGenre: Genre | null;
    }

    const GameGrid = ({ selectedGenre }: Props) => {
      // 将 selectedGenre 传递给 useGames 钩子
      const { data: games, error, isLoading } = useGames(selectedGenre);
      // ...
    };
    ```

4.  `hooks/useGames.ts` (适配 `selectedGenre`):

    ```ts
    import { Genre } from './useGenres';
    // ... Game 接口 ...

    // 假设 useGames 现在接收 selectedGenre
    const useGames = (selectedGenre: Genre | null) => {
      return useData<Game>(
        '/games',
        { params: { genres: selectedGenre?.id } }, // AxiosRequestConfig
        [selectedGenre?.id] // 依赖项数组
      );
    };
    ```

5.  `hooks/useData.ts` (修改后，接受 `requestConfig` 和 `deps`):

    ```ts
    // ... imports ...
    // AxiosRequestConfig 从 'axios' 导入

    const useData = <T>(
      endpoint: string,
      requestConfig?: AxiosRequestConfig, // 可选请求配置
      deps?: any[] // 可选依赖项
    ) => {
      // ... state variables ...

      useEffect(() => {
        const controller = new AbortController();
        setLoading(true);
        apiClient
          .get<FetchResponse<T>>(endpoint, {
            signal: controller.signal,
            ...requestConfig, // 合并传入的配置
          })
          // ... .then() .catch() ...
        setLoading(false); // 确保在 then 和 catch 中都设置
        return () => controller.abort();
      }, deps ? [...deps] : []); // 使用传入的依赖项，否则为空数组

      return { data, error, isLoading };
    };
    ```

## 22- 高亮显示选中的类型

> 简述：当用户在侧边栏选择一个游戏类型后，该类型在列表中以粗体显示，以提供明确的视觉反馈。

**知识树**

1.  状态传递:
    - `App` 组件已持有 `selectedGenre` 状态。
    - 将 `selectedGenre` 状态作为 prop 传递给 `GenreList` 组件。
2.  `GenreList` 组件修改:
    - 接收 `selectedGenre: Genre | null` prop。
    - 在渲染每个类型按钮 (`Button`) 时，动态设置其 `fontWeight` 样式属性。
    - 比较当前正在渲染的类型 (`genre.id`) 与 `selectedGenre?.id` (使用可选链，因为 `selectedGenre` 可能为 `null`)。
    - 如果 ID 匹配，设置 `fontWeight="bold"`；否则，设置 `fontWeight="normal"`。

**代码示例**

1.  `App.tsx` (已在上一节示例中包含 `selectedGenre` 传递给 `GenreList`):

    ```tsx
    // ...
    <GenreList
      selectedGenre={selectedGenre} // 传递选中的类型
      onSelectGenre={(genre) => setSelectedGenre(genre)}
    />
    // ...
    ```

2.  `components/GenreList.tsx` (动态设置 `fontWeight`):

    ```tsx
    // ... imports ...
    // Props 接口已包含 selectedGenre

    const GenreList = ({ selectedGenre, onSelectGenre }: Props) => {
      const { data: genres, isLoading, error } = useGenres();
      // ... isLoading, error handling ...
      return (
        <List>
          {genres.map((genre) => (
            <ListItem key={genre.id} paddingY="5px">
              <HStack>
                {/* ... Image ... */}
                <Button
                  variant="link"
                  fontSize="lg"
                  fontWeight={genre.id === selectedGenre?.id ? 'bold' : 'normal'} // 动态 fontWeight
                  onClick={() => onSelectGenre(genre)}
                >
                  {genre.name}
                </Button>
              </HStack>
            </ListItem>
          ))}
        </List>
      );
    };
    ```

## 23- 构建平台选择器

> 简述：创建一个下拉菜单组件 (`PlatformSelector`)，用于显示可选的游戏平台列表。数据从新的 API 端点获取，并使用 Chakra UI 的`Menu`相关组件进行渲染。

**知识树**

1.  Chakra UI `Menu` 组件:
    - `Menu`: 顶层包裹组件。
    - `MenuButton`: 作为触发菜单展开的按钮。
        - 可以内嵌一个 Chakra UI `Button`。
        - `rightIcon`: 可用于添加如图标 `BsChevronDown` (来自 `react-icons/bs`) 的向下箭头。
    - `MenuList`: 包含菜单项的列表容器。
    - `MenuItem`: 菜单中的单个可选项目。
2.  API 端点: `/platforms/lists/parents` 用于获取父平台列表 (一个更简洁的平台列表，如 PC, PlayStation, Xbox)。
3.  自定义钩子 (`hooks/usePlatforms.ts`):
    - 定义 `Platform` 接口 (如果尚未在共享位置定义): `{ id: number; name: string; slug: string; }`。
    - 调用通用 `useData<Platform>('/platforms/lists/parents')` 来获取平台数据。
4.  `PlatformSelector.tsx` 组件:
    - 使用 `usePlatforms` 钩子获取平台数据 (`data: platforms`) 和错误状态 (`error`)。
    - 如果获取数据出错 (`error` 为真)，则返回 `null` (不渲染组件)。
    - 动态渲染 `MenuItem`：遍历 `platforms` 数组，为每个平台创建一个 `MenuItem`。
        - `key={platform.id}`。
        - `MenuItem` 的内容为 `platform.name`。
5.  集成到主应用 (`App.tsx`):
    - 将 `PlatformSelector` 组件放置在 `GameGrid` 上方。

**代码示例**

1.  `hooks/usePlatforms.ts`:

    ```ts
    import useData from './useData';
    // Platform 接口定义 (若已在 useGames.ts 或共享类型文件定义，则导入)
    export interface Platform {
      id: number;
      name: string;
      slug: string;
    }

    const usePlatforms = () => useData<Platform>('/platforms/lists/parents');

    export default usePlatforms;
    ```

2.  `components/PlatformSelector.tsx`:

    ```tsx
    import { Button, Menu, MenuButton, MenuItem, MenuList } from '@chakra-ui/react';
    import { BsChevronDown } from 'react-icons/bs';
    import usePlatforms, { Platform } from '../hooks/usePlatforms';

    const PlatformSelector = () => {
      const { data: platforms, error } = usePlatforms();

      if (error) return null; // 错误时返回 null

      return (
        <Menu>
          <MenuButton as={Button} rightIcon={<BsChevronDown />}>
            Platforms {/* 初始静态文本，后续会动态化 */}
          </MenuButton>
          <MenuList>
            {platforms.map((platform) => (
              <MenuItem key={platform.id}>
                {platform.name}
              </MenuItem>
            ))}
          </MenuList>
        </Menu>
      );
    };

    export default PlatformSelector;
    ```

3.  `App.tsx` 中集成:

    ```tsx
    // ... imports ...
    import PlatformSelector from './components/PlatformSelector';

    function App() {
      // ... existing state (selectedGenre, etc.) ...
      return (
        <Grid /* ... */ >
          {/* ... Nav, Aside GridItems ... */}
          <GridItem area="main">
            <PlatformSelector /> {/* 添加平台选择器 */}
            <GameGrid selectedGenre={selectedGenre} /* ...其他 props... */ />
          </GridItem>
        </Grid>
      );
    }
    ```

## 24- 按平台筛选游戏

> 简述：实现通过`PlatformSelector`选择平台后，游戏网格仅显示对应平台的游戏。采用与类型筛选类似的状态提升和回调机制。

**知识树**

1.  状态管理 (`App.tsx`):
    - 添加 `selectedPlatform: Platform | null` 状态变量。
2.  回调与状态更新 (`PlatformSelector.tsx` -> `App.tsx`):
    - `PlatformSelector` 组件:
        - 添加 `onSelectPlatform: (platform: Platform) => void` prop。
        - 为每个 `MenuItem` 添加 `onClick={() => onSelectPlatform(platform)}` 事件处理器。
    - `App` 组件:
        - 传递 `(platform) => setSelectedPlatform(platform)` 给 `PlatformSelector` 的 `onSelectPlatform` prop。
3.  状态传递 (`App.tsx` -> `GameGrid.tsx`):
    - 将 `selectedPlatform` 状态作为 prop 传递给 `GameGrid` 组件。
4.  `GameGrid.tsx` 适配:
    - 添加 `selectedPlatform: Platform | null` prop。
    - 将 `selectedPlatform` 传递给 `useGames` 钩子。
5.  `useGames.ts` 钩子修改:
    - 接收 `selectedPlatform: Platform | null` 参数。
    - 在调用 `useData` 时，于 `requestConfig.params` 中添加 `platforms: selectedPlatform?.id`。
    - 将 `selectedPlatform?.id` 添加到 `useData` 的依赖项数组 `deps` 中。
6.  动态显示选中的平台名称 (`PlatformSelector.tsx`):
    - `App` 组件将 `selectedPlatform` 传递给 `PlatformSelector`。
    - `PlatformSelector` 接收 `selectedPlatform: Platform | null` prop。
    - `MenuButton` 的文本动态显示：`selectedPlatform?.name || 'Platforms'`。如果 `selectedPlatform` 存在，显示其名称，否则显示默认文本 "Platforms"。

**代码示例**

1.  `App.tsx` (状态管理与传递):

    ```tsx
    import { Platform } from './hooks/usePlatforms'; // 或从 useData 导出的类型
    // ... 其他导入和 useState ...

    function App() {
      // ... selectedGenre state ...
      const [selectedPlatform, setSelectedPlatform] = useState<Platform | null>(null);

      return (
        <Grid /* ... */ >
          {/* ... Nav, Aside GridItems ... */}
          <GridItem area="main">
            <PlatformSelector
              selectedPlatform={selectedPlatform} // 传递选中的平台
              onSelectPlatform={(platform) => setSelectedPlatform(platform)}
            />
            <GameGrid
              selectedGenre={selectedGenre}
              selectedPlatform={selectedPlatform} // 传递选中的平台给 GameGrid
            />
          </GridItem>
        </Grid>
      );
    }
    ```

2.  `components/PlatformSelector.tsx` (回调与动态文本):

    ```tsx
    // ... imports ...
    // Platform 接口已导入

    interface Props {
      selectedPlatform: Platform | null;
      onSelectPlatform: (platform: Platform) => void;
    }

    const PlatformSelector = ({ selectedPlatform, onSelectPlatform }: Props) => {
      const { data: platforms, error } = usePlatforms();
      if (error) return null;

      return (
        <Menu>
          <MenuButton as={Button} rightIcon={<BsChevronDown />}>
            {selectedPlatform?.name || 'Platforms'} {/* 动态文本 */}
          </MenuButton>
          <MenuList>
            {platforms.map((platform) => (
              <MenuItem
                key={platform.id}
                onClick={() => onSelectPlatform(platform)} // 点击回调
              >
                {platform.name}
              </MenuItem>
            ))}
          </MenuList>
        </Menu>
      );
    };
    ```

3.  `components/GameGrid.tsx` (接收 prop):

    ```tsx
    import { Platform } from '../hooks/usePlatforms';
    // ... Genre 接口 ...

    interface Props {
      selectedGenre: Genre | null;
      selectedPlatform: Platform | null;
    }

    const GameGrid = ({ selectedGenre, selectedPlatform }: Props) => {
      // 将 selectedPlatform 传递给 useGames 钩子
      const { data: games, error, isLoading } = useGames(selectedGenre, selectedPlatform);
      // ...
    };
    ```

4.  `hooks/useGames.ts` (适配 `selectedPlatform`):

    ```ts
    // ... Genre, Platform, Game 接口 ...

    const useGames = (selectedGenre: Genre | null, selectedPlatform: Platform | null) => {
      return useData<Game>(
        '/games',
        {
          params: {
            genres: selectedGenre?.id,
            parent_platforms: selectedPlatform?.id, // API 参数名为 parent_platforms
          },
        },
        [selectedGenre?.id, selectedPlatform?.id] // 添加到依赖项
      );
    };
    ```

    _注意：视频中 API 参数为 `platforms`，但根据 RAWG 文档，筛选父平台通常用 `parent_platforms`。此处遵循视频字幕。若实际 API 不同，需调整参数名。_

## 25- 重构-提取查询对象

> 简述：将`App`组件中用于游戏查询的多个独立状态变量（如`selectedGenre`, `selectedPlatform`）合并到一个名为`gameQuery`的对象中。这种“查询对象模式”有助于简化状态管理和 prop 传递，使代码更整洁，易于扩展。

**知识树**

1.  问题识别: `App` 组件中存在多个与游戏查询相关的状态变量，随着功能增加（如排序、搜索），状态变量数量会增多，导致 prop 传递复杂化和代码冗余。
2.  查询对象模式 (Query Object Pattern):
    - 定义一个接口 `GameQuery`，包含所有查询参数作为其属性 (例如 `genre: Genre | null`, `platform: Platform | null`, 后续可添加 `sortOrder: string`, `searchText: string` 等)。
    - 在 `App` 组件中，用一个 `gameQuery: GameQuery` 状态变量替换原有的多个独立状态变量。
    - 初始化 `gameQuery` 为一个空对象 `{}` 并断言其类型为 `GameQuery` ( `{} as GameQuery` )，因为初始时所有查询条件都为空。
3.  状态更新逻辑修改:
    - 当选择类型或平台时，调用 `setGameQuery` 更新状态。
    - 使用对象扩展运算符 (`...`) 保留 `gameQuery` 中未改变的属性，并更新当前操作相关的属性。例如: `setGameQuery({ ...gameQuery, genre: selectedGenre })`。
4.  Prop 传递简化:
    - `App` 组件现在只需将单个 `gameQuery` 对象传递给 `GameGrid`。
    - `GameGrid` 接收 `gameQuery: GameQuery` prop，并将其传递给 `useGames` 钩子。
5.  `useGames.ts` 钩子修改:
    - 接收单个 `gameQuery: GameQuery` 参数。
    - 在 `useData` 的 `requestConfig.params` 中，从 `gameQuery` 对象中提取相应的参数值 (例如 `genres: gameQuery.genre?.id`, `parent_platforms: gameQuery.platform?.id`)。
    - `useData` 的依赖项数组 `deps` 可以直接使用 `[gameQuery]`。当 `gameQuery` 对象的任何属性发生变化（导致对象引用变化）时，`useEffect` 会重新执行。
6.  接口导出与导入: `GameQuery` 接口需要在 `App.tsx` 中定义并导出，然后在 `GameGrid.tsx` 和 `useGames.ts` 中导入。

**代码示例**

1.  `App.tsx` (定义 `GameQuery` 并使用):

    ```tsx
    import { Genre } from './hooks/useGenres';
    import { Platform } from './hooks/usePlatforms';
    import { useState } from 'react';

    export interface GameQuery { // 定义并导出 GameQuery 接口
      genre: Genre | null;
      platform: Platform | null;
      // sortOrder: string; // 后续添加
      // searchText: string; // 后续添加
    }

    function App() {
      const [gameQuery, setGameQuery] = useState<GameQuery>({} as GameQuery);

      return (
        <Grid /* ... */ >
          <Show above="lg">
            <GridItem area="aside" paddingX={5}>
              <GenreList
                selectedGenre={gameQuery.genre}
                onSelectGenre={(genre) => setGameQuery({ ...gameQuery, genre })}
              />
            </GridItem>
          </Show>
          <GridItem area="main">
            <PlatformSelector
              selectedPlatform={gameQuery.platform}
              onSelectPlatform={(platform) => setGameQuery({ ...gameQuery, platform })}
            />
            {/* SortSelector (后续添加) */}
            <GameGrid gameQuery={gameQuery} /> {/* 传递整个 gameQuery 对象 */}
          </GridItem>
        </Grid>
      );
    }
    ```

2.  `components/GameGrid.tsx` (接收 `gameQuery`):

    ```tsx
    import { GameQuery } from '../App'; // 导入 GameQuery 接口

    interface Props {
      gameQuery: GameQuery;
    }

    const GameGrid = ({ gameQuery }: Props) => {
      const { data: games, error, isLoading } = useGames(gameQuery); // 传递 gameQuery
      // ...
    };
    ```

3.  `hooks/useGames.ts` (适配 `gameQuery`):

    ```ts
    import { GameQuery } from '../App'; // 导入 GameQuery 接口
    // ... Game 接口 ...

    const useGames = (gameQuery: GameQuery) => {
      return useData<Game>(
        '/games',
        {
          params: {
            genres: gameQuery.genre?.id,
            parent_platforms: gameQuery.platform?.id,
            // ordering: gameQuery.sortOrder, // 后续添加
            // search: gameQuery.searchText, // 后续添加
          },
        },
        [gameQuery] // 依赖整个 gameQuery 对象
      );
    };
    ```

## 26- 构建排序选择器

> 简述：创建一个新的下拉菜单组件 (`SortSelector`)，用于提供不同的游戏排序选项。此阶段仅构建 UI，实际排序逻辑将在后续实现。同时调整选择器之间的布局。

**知识树**

1.  组件创建 (`SortSelector.tsx`):
    - UI 结构与 `PlatformSelector` 非常相似，可以复用其 Chakra UI `Menu`, `MenuButton`, `Button`, `MenuList`, `MenuItem` 结构。
    - `MenuButton` 初始静态文本 (例如 "Order by: Relevance")。
    - `MenuItem` 包含预定义的排序选项文本 (例如 "Relevance", "Date added", "Name", "Release date", "Popularity", "Average rating")。
2.  集成到主应用 (`App.tsx`):
    - 将 `SortSelector` 组件放置在 `PlatformSelector` 之后，`GameGrid` 之前。
3.  布局调整 (`App.tsx`):
    - 使用 Chakra UI `HStack` 组件包裹 `PlatformSelector` 和 `SortSelector`，以实现水平排列。
        - `HStack` 的 `spacing` 属性 (例如 `5`) 控制选择器之间的间距。
    - 为 `HStack` 添加 `paddingLeft` (例如 `2` 或 `10px`)，使其与下方的游戏卡片左侧对齐。
    - 为 `HStack` 添加 `marginBottom` (例如 `5`)，以在选择器组和游戏网格之间创建垂直间距。

**代码示例**

1.  `components/SortSelector.tsx`:

    ```tsx
    import { Button, Menu, MenuButton, MenuItem, MenuList } from '@chakra-ui/react';
    import { BsChevronDown } from 'react-icons/bs';

    const SortSelector = () => {
      const sortOrders = [ // 静态排序选项，后续会动态化和添加value
        { value: '', label: 'Relevance' },
        { value: '-added', label: 'Date added' },
        { value: 'name', label: 'Name' },
        { value: '-released', label: 'Release date' },
        { value: '-metacritic', label: 'Popularity' },
        { value: '-rating', label: 'Average rating' },
      ];

      return (
        <Menu>
          <MenuButton as={Button} rightIcon={<BsChevronDown />}>
            Order by: Relevance {/* 初始静态文本, 后续动态 */}
          </MenuButton>
          <MenuList>
            {sortOrders.map(order => (
              <MenuItem key={order.value}>
                {order.label}
              </MenuItem>
            ))}
          </MenuList>
        </Menu>
      );
    };

    export default SortSelector;
    ```

2.  `App.tsx` (集成 `SortSelector` 并调整布局):

    ```tsx
    // ... imports ...
    import SortSelector from './components/SortSelector';
    import { HStack } from '@chakra-ui/react'; // 导入 HStack

    function App() {
      const [gameQuery, setGameQuery] = useState<GameQuery>({} as GameQuery);

      return (
        <Grid /* ... */ >
          {/* ... Nav, Aside GridItems ... */}
          <GridItem area="main">
            <HStack spacing={5} paddingLeft={2} marginBottom={5}> {/* HStack 包裹选择器 */}
              <PlatformSelector
                selectedPlatform={gameQuery.platform}
                onSelectPlatform={(platform) => setGameQuery({ ...gameQuery, platform })}
              />
              <SortSelector /> {/* 添加排序选择器 */}
            </HStack>
            <GameGrid gameQuery={gameQuery} />
          </GridItem>
        </Grid>
      );
    }
    ```

## 27- 排序游戏

> 简述：实现通过`SortSelector`选择排序方式后，游戏网格按选定顺序重新排列游戏。涉及将排序选项添加到`GameQuery`，更新回调，修改`useGames`钩子以包含排序参数，并动态显示当前排序方式。

**知识树**

1.  API 排序参数: RAWG API 使用 `ordering` 查询参数进行排序。参数值可以是字段名 (如 `name`, `released`, `added`, `metacritic`, `rating`)。前缀 `-` 表示降序 (例如 `-released` 表示按发行日期降序)。
2.  `SortSelector.tsx` 增强:
    - 定义 `sortOrders` 数组，每个元素是对象 `{ value: string; label: string; }`。`value` 是发送给 API 的 `ordering` 参数值，`label` 是显示给用户的文本。
    - 动态渲染 `MenuItem`，并为每个 `MenuItem` 设置 `key={order.value}` 和 `onClick={() => onSelectSortOrder(order.value)}`。
    - 添加 `onSelectSortOrder: (sortOrder: string) => void` prop 用于回调。
    - 添加 `selectedSortOrder: string` prop 用于接收当前选中的排序值，以动态更新 `MenuButton` 的文本。
        - `MenuButton` 文本: `sortOrders.find(order => order.value === selectedSortOrder)?.label || 'Relevance'`。
3.  `GameQuery` 接口更新 (`App.tsx`):
    - 添加 `sortOrder: string` 属性。
4.  `App.tsx` 状态与回调:
    - `gameQuery` 初始化时，`sortOrder` 可以为空字符串或默认排序值。
    - 传递 `gameQuery.sortOrder` 给 `SortSelector` 的 `selectedSortOrder` prop。
    - 传递 `(sortOrder) => setGameQuery({ ...gameQuery, sortOrder })` 给 `SortSelector` 的 `onSelectSortOrder` prop。
5.  `useGames.ts` 钩子修改:
    - 从 `gameQuery` 对象中获取 `sortOrder`。
    - 在 `useData` 的 `requestConfig.params` 中添加 `ordering: gameQuery.sortOrder`。
    - 由于 `gameQuery` 整体已是 `useData` 的依赖项，`sortOrder` 的变化会自动触发数据重新获取。
6.  临时错误处理 (`image-url.ts`):
    - 视频中遇到某些游戏没有 `background_image` 导致 `getCroppedImageUrl` 出错的问题。
    - 临时修复：在 `getCroppedImageUrl` 函数开头检查 `url` 是否为假值 (falsy)，如果是则返回空字符串。后续章节会用占位图改进。

**代码示例**

1.  `components/SortSelector.tsx` (增强版):

    ```tsx
    // ... imports ...

    interface Props {
      selectedSortOrder: string | undefined; // 允许 undefined 对应初始状态
      onSelectSortOrder: (sortOrder: string) => void;
    }

    const SortSelector = ({ selectedSortOrder, onSelectSortOrder }: Props) => {
      const sortOrders = [
        { value: '', label: 'Relevance' }, // 默认排序，value 为空
        { value: '-added', label: 'Date added' },
        { value: 'name', label: 'Name' },
        { value: '-released', label: 'Release date' },
        { value: '-metacritic', label: 'Popularity' },
        { value: '-rating', label: 'Average rating' },
      ];

      const currentSortOrder = sortOrders.find(order => order.value === selectedSortOrder);

      return (
        <Menu>
          <MenuButton as={Button} rightIcon={<BsChevronDown />}>
            Order by: {currentSortOrder?.label || 'Relevance'}
          </MenuButton>
          <MenuList>
            {sortOrders.map((order) => (
              <MenuItem
                key={order.value}
                onClick={() => onSelectSortOrder(order.value)}
              >
                {order.label}
              </MenuItem>
            ))}
          </MenuList>
        </Menu>
      );
    };
    ```

2.  `App.tsx` (更新 `GameQuery` 和回调):

    ```tsx
    export interface GameQuery {
      genre: Genre | null;
      platform: Platform | null;
      sortOrder?: string; // 改为可选，或在 useState 初始化时提供默认值
    }

    function App() {
      const [gameQuery, setGameQuery] = useState<GameQuery>({ sortOrder: '' } as GameQuery); // 初始 sortOrder

      return (
        <Grid /* ... */ >
          {/* ... */}
          <GridItem area="main">
            <HStack /* ... */ >
              {/* ... PlatformSelector ... */}
              <SortSelector
                selectedSortOrder={gameQuery.sortOrder}
                onSelectSortOrder={(sortOrder) => setGameQuery({ ...gameQuery, sortOrder })}
              />
            </HStack>
            <GameGrid gameQuery={gameQuery} />
          </GridItem>
        </Grid>
      );
    }
    ```

3.  `hooks/useGames.ts` (添加 `ordering` 参数):

    ```tsx
    // ... GameQuery 导入 ...

    const useGames = (gameQuery: GameQuery) => {
      return useData<Game>(
        '/games',
        {
          params: {
            genres: gameQuery.genre?.id,
            parent_platforms: gameQuery.platform?.id,
            ordering: gameQuery.sortOrder, // 添加排序参数
          },
        },
        [gameQuery]
      );
    };
    ```

4.  `services/image-url.ts` (临时错误修复):
    ```ts
    const getCroppedImageUrl = (url: string) => {
      if (!url) return ''; // 如果 URL 为空或 undefined，返回空字符串
      // ... rest of the logic ...
    };
    ```

## 28- 处理无图像的游戏

> 简述：为那些 API 未提供背景图像的游戏显示一个默认的占位符图像，而不是显示空白或导致错误。

**知识树**

1.  占位符图像:
    - 准备一个本地的占位符图像文件 (例如 `no-image-placeholder.webp`)。
    - 将其放置在项目的 `src/assets` 文件夹中。
2.  静态资源导入 (`image-url.ts`):
    - 由于占位符图像是与应用一起部署的静态资源，不能直接使用相对文件路径字符串。
    - 需要像导入 JavaScript 模块一样导入图像：`import noImagePlaceholder from '../assets/no-image-placeholder.webp';`。
    - Webpack (或 Vite 等构建工具) 会处理这个导入，使其在运行时可用。
3.  `getCroppedImageUrl` 函数修改 (`image-url.ts`):
    - 当原始 `url` 参数为假值 (falsy) 时，不再返回空字符串，而是返回导入的 `noImagePlaceholder` 变量。

**代码示例**

1.  `services/image-url.ts` (使用占位符图像):

    ```ts
    import noImagePlaceholder from '../assets/no-image-placeholder.webp'; // 导入占位符图像

    const getCroppedImageUrl = (url: string): string => { // 明确返回类型为 string
      if (!url) return noImagePlaceholder; // 如果 URL 无效，返回占位符

      const target = 'media/';
      const index = url.indexOf(target) + target.length;
      if (index < target.length) return noImagePlaceholder; // 如果 'media/' 不存在，也返回占位符

      return url.slice(0, index) + 'crop/600/400/' + url.slice(index);
    };

    export default getCroppedImageUrl;
    ```

    - 确保 `no-image-placeholder.webp` 文件存在于 `src/assets/` 目录下。

## 29- 修复 Chakra 菜单问题

> 简述：解决在`HStack`中嵌套 Chakra UI `Menu`组件时，控制台可能出现的关于`margin`和`padding`的警告。通过将`HStack`替换为`Flex`组件，并手动调整间距来修复此问题。

**知识树**

1.  问题现象: 当 `PlatformSelector` 和 `SortSelector` (均为 Chakra `Menu`组件) 被包裹在 `HStack` 中并设置了 `spacing` 时，选择菜单项可能会在控制台触发警告，内容大致为 "css margin styles cannot be used to apply padding..."。
2.  根本原因 (推测): `HStack` 内部可能使用某些特定的 CSS 实现其 `spacing`，这与 `Menu` 组件（特别是其弹出部分，即 Popper）的定位或样式计算方式产生冲突。
3.  解决方案:
    - 将包裹选择器的 `HStack` 组件替换为 Chakra UI 的 `Flex` 组件。`Flex` 是更底层的布局组件，默认情况下不自动应用子元素间的间距。
    - 移除原 `HStack` 的 `spacing` prop。
    - 手动为其中一个选择器（例如 `PlatformSelector`）包裹一个 `Box` 组件，并为该 `Box` 设置 `marginRight` (或 `marginLeft`，取决于哪个选择器被包裹) 来创建选择器之间的间距。
4.  `Flex` 组件:
    - 默认 `flexDirection` 是 `row`，因此替换 `HStack` 后仍能保持水平布局。
    - 其他需要的对齐和分布属性 (如 `alignItems`, `justifyContent`) 可以直接在 `Flex` 上设置。

**代码示例**

1.  `App.tsx` (使用 `Flex` 和 `Box` 调整间距):

    ```tsx
    // ... imports ...
    import { Flex, Box } from '@chakra-ui/react'; // 导入 Flex 和 Box

    function App() {
      const [gameQuery, setGameQuery] = useState<GameQuery>({ sortOrder: '' } as GameQuery);

      return (
        <Grid /* ... */ >
          {/* ... Nav, Aside GridItems ... */}
          <GridItem area="main">
            <Flex paddingLeft={2} marginBottom={5}> {/* HStack 替换为 Flex */}
              <Box marginRight={5}> {/* 为 PlatformSelector 包裹 Box 并设置右边距 */}
                <PlatformSelector
                  selectedPlatform={gameQuery.platform}
                  onSelectPlatform={(platform) => setGameQuery({ ...gameQuery, platform })}
                />
              </Box>
              <SortSelector
                selectedSortOrder={gameQuery.sortOrder}
                onSelectSortOrder={(sortOrder) => setGameQuery({ ...gameQuery, sortOrder })}
              />
            </Flex>
            <GameGrid gameQuery={gameQuery} />
          </GridItem>
        </Grid>
      );
    }
    ```

    - 原 `HStack` 的 `spacing={5}` 被 `Box` 的 `marginRight={5}` 替代。
    - `paddingLeft` 和 `marginBottom` 仍可应用于 `Flex` 组件。
