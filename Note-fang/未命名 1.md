## React Query 数据变更（Mutating Data）

> **简述：**  
> 在 React Query 中，数据变更（Mutation）指向后端发送“写”操作（如创建、更新、删除），并将结果同步到本地缓存与界面。核心工具是 `useMutation` 钩子，它能够简化请求函数的封装、错误处理和缓存更新；配合 `useQueryClient` 可实现自动或手动更新本地缓存。本节详细剖析 `useMutation` 的目的、参数、返回值与回调机制，并说明教师在示例中实现新增 To-Do 的思路与顺序，确保读者仅凭笔记即可独立完成开发。

---

**知识树**

1.  **本节重点知识**  
    1.1 **useMutation**：  
      1.1.1 用途  
      1.1.2 参数概览  
      1.1.3 返回值（MutationResult）  
      1.1.4 回调函数（onMutate、onSuccess、onError、onSettled）  
      1.1.5 常见用法场景（创建、更新、删除）  
      1.1.6 注意事项（类型校验、不可变更新、空值处理等）

    1.2 **useQueryClient**：  
      1.2.1 用途：获取全局 QueryClient 实例  
      1.2.2 方法：  
       • `invalidateQueries(queryKey)`  
       • `setQueryData(queryKey, updater)`  
       • `getQueryData`、`removeQueries` 等

    1.3 **表单与输入校验**：  
      1.3.1 `useRef` 获取 `<input>` 值  
      1.3.2 `e.preventDefault()` 阻止默认刷新  
      1.3.3 `trim()` + 空字符串判断

    1.4 **缓存更新策略**：  
      1.4.1 失效缓存（Invalidate）  
      1.4.2 直接更新缓存（setQueryData）

2.  **useMutation 详解**  
    2.1 **用途**  
      • 封装“写”操作（POST/PUT/DELETE 等），替代手动管理请求和状态。  
      • 提供加载状态 `isLoading`、错误状态 `isError`、返回数据 `data` 等。  
      • 支持多个回调：`onMutate`（请求发起前）、`onSuccess`、`onError`、`onSettled`。  
      • 与 `useQueryClient` 配合，可在回调中更新或失效缓存，实现乐观更新或自动刷新。

    2.2 **参数**  
      因 `useMutation` 接受多种重载方式，最常见的写法为：

    ```ts
    const mutation = useMutation<
      TData,        // 后端返回的数据类型
      TError,       // 可能抛出的错误类型
      TVariables,   // 传入 mutationFn 的变量类型
      TContext      // （可选）onMutate 返回并供 onError 回滚的上下文类型
    >(
      mutationFn,   // 必填：定义如何向后端发起请求
      {            // 可选：各种回调的配置对象
        onMutate, onSuccess, onError, onSettled
      }
    );
    ```

    - **mutationFn**：一个函数，签名 `(variables: TVariables) => Promise<TData>`。
        - `variables`：调用 `mutate(variables)` 时传入的参数。
        - 函数内部通常使用 `axios.post`、`axios.put` 等发送请求并返回一个 `Promise`。
    - **第二个参数（配置对象）**：可选属性：

        - `onMutate(variables: TVariables) => TContext | Promise<TContext>`：在请求发起前执行，可返回上下文用于后续回滚。
        - `onSuccess(data: TData, variables: TVariables, context?: TContext) => void`：请求成功后的回调。
        - `onError(error: TError, variables: TVariables, context?: TContext) => void`：请求失败时调用，可利用 `context` 回滚。
        - `onSettled(data: TData | undefined, error: TError | null, variables: TVariables, context?: TContext) => void`：无论成功或失败都会执行，适合清理或隐藏加载态。

- 2.3 **返回值（MutationResult 对象）**  
     该对象包含多种属性与方法：

    - `mutate(variables: TVariables, options?: { onSuccess, onError, onSettled })`：触发 mutation。
    - `mutateAsync(variables: TVariables, options?) => Promise<TData>`：返回 Promise，方便 `async/await`。
    - `data: TData | undefined`：最近一次成功请求返回的数据。
    - `error: TError | null`：最近一次失败时的错误。
    - `isLoading: boolean`：当前是否处于请求阶段。
    - `isError: boolean`、`isSuccess: boolean`, `status: 'idle' | 'loading' | 'error' | 'success'` 等。

        2.4 **回调函数详解**

    - **onMutate**：
        - 在请求发起前被调用，常用于乐观更新：先修改本地缓存，然后在 `onError` 中回滚。
        - 返回值类型 `TContext`，会传递给后续的 `onError` 或 `onSettled`。
    - **onSuccess**：
        - 请求成功后调用，参数：`(data: TData, variables: TVariables, context?: TContext)`。
        - 推荐在此处调用 `queryClient.setQueryData` 或 `invalidateQueries` 更新缓存。
    - **onError**：
        - 请求失败后调用，参数：`(error: TError, variables: TVariables, context?: TContext)`。
        - 若使用乐观更新，可在此通过 `context` 回滚到原始状态。
    - **onSettled**：

        - 请求完成（成功或失败）后都会执行，适合收尾操作，如隐藏加载指示或重置表单。

            2.5 **常见用法场景**

    - **创建（Create）**：提交表单后发起 `POST` 请求，将新项插入数据库，并更新 UI。
    - **更新（Update）**：发送 `PUT`/`PATCH` 请求，将局部字段修改为新值。
    - **删除（Delete）**：调用 `DELETE` 请求后从本地列表中移除对应项。

        2.6 **注意事项**

    - **类型安全**：务必在调用 `useMutation` 时指定泛型，以保证回调参数类型正确。
    - **空值与可空链**：当使用 `ref.current?.value` 时，若 `current` 为 `null`，需防止直接传 `undefined` 给 `mutate`。
    - **不可变更新**：在回调（如 `onSuccess`）中更新缓存时，切勿修改原始数组，需返回新数组。
    - **乐观更新风控**：若要在提交前就更新 UI，需在 `onMutate` 中先修改缓存并在 `onError` 时回滚；否则可直接在 `onSuccess` 中更新。
    - **真实 API vs JSON Placeholder**：示例中使用 JSON Placeholder，POST 后服务器并不真正保存数据，因此“失效缓存”方式在示例中不能立即看到新增效果，但在真实后端中是完全正确的做法。

3.  **useQueryClient 详解**  
    3.1 **用途**  
      • 拿到全局的 `QueryClient` 实例，负责维护所有查询（Queries）与变更（Mutations）的缓存与状态。

    3.2 **常用方法**

    - `queryClient.invalidateQueries({ queryKey: … })`：将与该 `queryKey` 匹配的所有查询标记为「过期」，下次渲染或聚焦页面时会自动重新发起请求。
    - `queryClient.setQueryData<T>(queryKey, updaterFn: (oldData: T | undefined) => T)`：直接用新的数据覆盖或合并旧缓存，适用于新增、更新、删除等“即时”更新场景。
    - `queryClient.getQueryData<T>(queryKey)`：获取当前缓存的数据（同步）。
    - `queryClient.removeQueries({ queryKey })`：手动清除特定查询缓存。

4.  **表单实现与校验**  
    4.1 **useRef 获取值**  
      通过 `const inputRef = useRef<HTMLInputElement>(null)` 获取 `<input>` 的 DOM 引用，使用 `inputRef.current?.value` 读取内容。

    4.2 **preventDefault**  
      在 `onSubmit` 回调中执行 `e.preventDefault()`，阻止表单自动刷新页面。

    4.3 **trim 与空值判断**  
      使用 `value = inputRef.current?.value.trim()`，若 `value === ''`，则不调用 `mutate`，避免发送空内容。

5.  **缓存更新策略**  
    5.1 **失效缓存（Invalidate）**  
      • 场景：新增/更新/删除后，希望下次自动从服务器重新获取最新列表。  
      • 实现：在 `onSuccess` 回调中：

    ```ts
    queryClient.invalidateQueries({ queryKey: ['todos'] });
    ```

    • 特点：保证拿到服务器真实数据，但会多一次网络请求。JSON Placeholder 示例中无法立刻看到更新，因为后台不会真正保存。

    5.2 **直接更新缓存（setQueryData）**  
      • 场景：新增或删除后，在本地立即反映变更，无需额外请求。  
      • 实现：在 `onSuccess` 回调中：

    ```ts
    queryClient.setQueryData<ToDo[]>(['todos'], (oldTodos = []) => {
      return [savedToDo, ...oldTodos];
    });
    ```

    • 特点：无需重复请求，体验更流畅；需自己维护不可变更新逻辑，处理 `oldTodos` 可能为 `undefined`。

6.  **教师演示 Mutate 的思路与实现顺序**  
    6.1 **准备阶段**  
      • 在项目目录下已有 `useTodos.ts`，定义并导出了 `interface ToDo { userId: number; id: number; title: string; completed: boolean; }`。  
      • 已完成 `ToDoList` 组件，能通过 `useQuery<ToDo[]>` 正常获取并渲染列表。

    6.2 **引入依赖**  
      • 在 `ToDoForm.tsx` 文件顶部：

    ```ts
    import React, { useRef } from 'react';
    import axios from 'axios';
    import { useMutation, useQueryClient } from '@tanstack/react-query';
    import { ToDo } from './useTodos';
    ```

    • 定义后端接口常量：

    ```ts
    const TODOS_URL = 'https://jsonplaceholder.typicode.com/todos';
    ```

    6.3 **定义 mutationFn**  
      • 教师在外部或组件内定义：

    ```ts
    const addToDoRequest = async (newToDo: ToDo): Promise<ToDo> => {
      const response = await axios.post<ToDo>(TODOS_URL, newToDo);
      return response.data;
    };
    ```

    • 作用：负责向后端发送 `POST` 请求，返回服务器返回的完整 `ToDo` 对象（带 `id`）。

    6.4 **调用 useMutation 并配置回调**  
      • 在组件内部：

    ```ts
    const queryClient = useQueryClient();

    const addToDoMutation = useMutation<ToDo, Error, ToDo>(
      addToDoRequest,
      {
        onSuccess: (savedToDo, variables) => {
          // ① 直接更新缓存（本地插入新纪录）
          queryClient.setQueryData<ToDo[]>(
            ['todos'],
            (oldTodos = []) => [savedToDo, ...oldTodos]
          );

          // ② 如果要使用失效缓存方式，则用：
          // queryClient.invalidateQueries({ queryKey: ['todos'] });
        },
        onError: (error) => {
          // 可选：展示错误提示
          console.error('创建失败：', error);
        },
        onSettled: () => {
          // 可选：隐藏加载状态、清空表单等
        },
      }
    );
    ```

    • **思考顺序：**  
       1) 第一步传入 `addToDoRequest`，明确如何发起请求。  
       2) 指定泛型：`<ToDo, Error, ToDo>`，确保回调里 `savedToDo` 与 `variables` 类型正确。  
       3) 在 `onSuccess` 中选择“直接更新”或“失效缓存”策略；教师示例采用“直接更新”演示更流畅的体验。

    6.5 **表单提交逻辑**  
      • 在组件内创建引用与提交函数：

    ```ts
    const inputRef = useRef<HTMLInputElement>(null);

    const handleSubmit = (e: React.FormEvent) => {
      e.preventDefault();

      const title = inputRef.current?.value.trim();
      if (!title) return;

      const newToDo: ToDo = {
        userId: 1,
        id: 0,              // 后端返回时会被替换
        title,
        completed: false,
      };

      // 调用 mutate 发起请求
      addToDoMutation.mutate(newToDo);

      // 可选：清空输入框
      inputRef.current.value = '';
    };
    ```

    • **思路顺序：**  
       4) 防止表单默认刷新；  
       5) 获取并裁剪输入，若为空则直接返回；  
       6) 构建待发送的 `newToDo` 对象；  
       7) 调用 `mutate(newToDo)`，触发 `addToDoRequest`；  
       8) 清空输入框，准备下一次输入。

    6.6 **整体测试与验证**  
      • **场景一（空值）**：  
       - 浏览器 DevTools Network：无 POST 请求。  
      • **场景二（正常输入）**：  
       - Network 出现 `POST /todos` → 服务器返回带 `id` 的对象。  
       - 回到 `onSuccess`，执行 `setQueryData`，缓存列表新增一项，页面即时渲染。  
      • **场景三（失效缓存示例，若为真实 API）**：  
       - 在 `onSuccess` 改用 `invalidateQueries`，则列表会重新发起 GET 请求拿到服务器最新数据。

---

**代码示例**

```tsx
// ToDoForm.tsx
import React, { useRef } from 'react';
import axios from 'axios';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { ToDo } from './useTodos';

// 后端接口地址常量
const TODOS_URL = 'https://jsonplaceholder.typicode.com/todos';

// 1. 定义 mutationFn：负责向后端 POST newToDo，返回 Promise<ToDo>
const addToDoRequest = async (newToDo: ToDo): Promise<ToDo> => {
  const response = await axios.post<ToDo>(TODOS_URL, newToDo);
  return response.data;
};

export const ToDoForm: React.FC = () => {
  // 2. useRef 获取 input DOM 引用
  const inputRef = useRef<HTMLInputElement>(null);

  // 3. useQueryClient 用于缓存操作
  const queryClient = useQueryClient();

  // 4. 调用 useMutation，传入 mutationFn 与回调
  const addToDoMutation = useMutation<ToDo, Error, ToDo>(
    addToDoRequest,
    {
      onSuccess: (savedToDo, newToDo) => {
        // 4.1 直接更新缓存：将 savedToDo 插入到本地 todos 列表开头
        queryClient.setQueryData<ToDo[]>(
          ['todos'],
          (oldTodos = []) => [savedToDo, ...oldTodos]
        );

        // 4.2 若采用失效缓存策略，请改成：
        // queryClient.invalidateQueries({ queryKey: ['todos'] });

        console.log('新增成功，返回：', savedToDo);
      },
      onError: (error) => {
        // 4.3 请求失败时处理
        console.error('新增失败：', error);
      },
      onSettled: () => {
        // 4.4 无论成功或失败都可在此处收尾
      },
    }
  );

  // 5. 处理表单提交
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    // 5.1 读取并裁剪输入
    const title = inputRef.current?.value.trim();
    if (!title) return;

    // 5.2 构建新 ToDo 对象
    const newToDo: ToDo = {
      userId: 1,
      id: 0,
      title,
      completed: false,
    };

    // 5.3 调用 mutate 触发请求
    addToDoMutation.mutate(newToDo);

    // 5.4 清空输入框
    if (inputRef.current) {
      inputRef.current.value = '';
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        ref={inputRef}
        placeholder="输入新的待办事项"
      />
      <button type="submit">添加</button>
    </form>
  );
};
```

```tsx
// ToDoList.tsx
import React from 'react';
import axios from 'axios';
import { useQuery } from '@tanstack/react-query';
import { ToDo } from './useTodos';

const TODOS_URL = 'https://jsonplaceholder.typicode.com/todos';

// 1. 定义获取 ToDo 列表的函数
const fetchToDos = async (): Promise<ToDo[]> => {
  const response = await axios.get<ToDo[]>(TODOS_URL);
  return response.data;
};

export const ToDoList: React.FC = () => {
  // 2. useQuery 获取并渲染 ToDo 列表
  const { data: todos, isLoading, isError, error } = useQuery<ToDo[], Error>(
    ['todos'],
    fetchToDos
  );

  if (isLoading) return <p>加载中...</p>;
  if (isError) return <p>加载失败：{error.message}</p>;

  return (
    <ul>
      {todos!.map((todo) => (
        <li key={todo.id}>
          #{todo.id} — {todo.title} [{todo.completed ? '已完成' : '未完成'}]
        </li>
      ))}
    </ul>
  );
};
```

```tsx
// App.tsx
import React from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ToDoForm } from './ToDoForm';
import { ToDoList } from './ToDoList';

// 1. 创建全局 QueryClient
const queryClient = new QueryClient();

export const App: React.FC = () => {
  return (
    <QueryClientProvider client={queryClient}>
      <>
        <h1>待办列表（示例：React Query 数据变更）</h1>
        <ToDoForm />
        <ToDoList />
      </>
    </QueryClientProvider>
  );
};
```

> **总结：**
>
> -   通过详细掌握 `useMutation` 的各项参数与回调，能够自主封装任何“写”类型请求，并结合 `useQueryClient` 在本地缓存层面做增删改操作。
> -   本节笔记先列出 `useMutation` 的目的、参数、返回值与注意事项，然后拆解教师实现思路与顺序，读者仅需参考本笔记即可复刻完整示例。

以下从五个方面对 “React Query” 进行深入讲解：

---

## 1. 通俗解释

- **比喻：图书馆与借书系统**  
     想象你在一座大型图书馆里学习。React Query 就像图书馆的借书系统：
    - 当你要看一本书（数据），借书系统会先检查图书馆里有没有（缓存），如果有就直接借给你（直接读取缓存）；
    - 如果馆内没有或者需要更新（缓存过期），系统会去总库调运（发起网络请求），把最新的书调过来给你（拿到最新数据），并且把它放入图书馆（更新缓存），供后续借阅；
    - 当你看完书后，系统会记录这本书的借阅状态、借阅时间等信息（管理加载状态、错误状态等）。  
         这样，你就不用自己去翻书架（手写 fetch/axios、管理 loading & error）——React Query 帮你打理好 “借书 → 归还” 的整个流程。

---

## 2. React Query 解决的问题

1. **网络请求的重复与缓存**

    - 传统做法是每次组件挂载就 `fetch`，容易造成同一个数据被反复拉取。
    - React Query 内置缓存机制：同一个 “查询键（query key）” 在缓存未过期的情况下，会直接复用上一次的数据，避免多余请求。

2. **数据与界面状态管理（Loading、Error、Empty 等）**

    - 自己手写时要维护 `isLoading`、`isError`、`error`、`data` 等多个 `useState`，容易冗余。
    - React Query 通过 `useQuery` 返回一组统一的状态值（如 `isLoading`、`isError`、`data` 等），更加规范、减少样板代码。

3. **缓存失效（Stale）与自动重新获取（Refetch）**

    - 后端数据可能随时变化，需要保持前端与服务端数据一致。
    - React Query 支持多种自动 `refetch` 方式：如窗口重新获得焦点时自动拉取（`refetchOnWindowFocus`）、网络重连时自动拉取（`refetchOnReconnect`）、定时轮询（`refetchInterval`）等，让数据保持最新。

4. **并发请求与去重（Deduplication）**

    - 当多个组件同时请求同一个资源时，React Query 会合并成一次真正的网络请求，避免浪费。

5. **Mutation（数据提交/变更）与变更后的缓存更新**

    - 对于新增/更新/删除操作，传统做法要手动更新本地缓存（或者强制刷新）。
    - React Query 的 `useMutation` 配合 `onSuccess`（或 `invalidateQueries`）可以在变更后自动刷新或更新相关查询，保证缓存一致性。

---

## 3. 详细语法与常用选项

以下示例基于 React Query v4（`@tanstack/react-query`）写法，涵盖主要 API 及常见配置选项：

### 3.1 安装与基础配置

```bash
npm install @tanstack/react-query
# 或者
yarn add @tanstack/react-query
```

在应用入口处创建并注入 `QueryClient`：

```jsx
import React from "react";
import ReactDOM from "react-dom";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import App from "./App";

const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			// 全局默认配置，可在这里统一设置
			refetchOnWindowFocus: true, // 窗口重新聚焦时自动 refetch
			retry: 2, // 请求失败自动重试 2 次
			staleTime: 1000 * 60 * 5, // 缓存数据 5 分钟内都视为新鲜
			cacheTime: 1000 * 60 * 10, // 缓存存活时间 10 分钟
		},
		mutations: {
			retry: 1, // 失败重试 1 次
		},
	},
});

ReactDOM.render(
	<QueryClientProvider client={queryClient}>
		<App />
	</QueryClientProvider>,
	document.getElementById("root")
);
```

- **`QueryClient`**：核心实例，负责管理所有 Query 和 Mutation 数据与状态。
- **`QueryClientProvider`**：React 上下文提供器，必须包裹应用，才能在任意组件中使用 `useQuery`、`useMutation` 等。

### 3.2 `useQuery`：数据获取

```jsx
import { useQuery } from "@tanstack/react-query";
import axios from "axios";

function ExampleComponent() {
	const {
		data, // 后端返回的实际数据
		isLoading, // 是否正在加载中
		isError, // 是否发生错误
		error, // 错误对象
		isFetching, // 是否正触发后端请求（即使 data 已有旧数据）
		refetch, // 手动触发重新获取的函数
	} = useQuery(
		["todos", { page: 1 }], // queryKey：唯一标识，一般使用数组形式。常见写法：['资源标识', 参数对象]
		() => axios.get("/api/todos?page=1").then((res) => res.data), // queryFn：返回 Promise，必须在函数内部返回数据
		{
			// 配置选项（局部覆盖 global）
			staleTime: 1000 * 60 * 2, // 数据 2 分钟内都算 fresh
			cacheTime: 1000 * 60 * 5, // 缓存 5 分钟后才会被 garbage collect
			enabled: true, // 是否自动启动请求（可设为 false 延迟加载）
			refetchOnWindowFocus: false, // 禁用窗口获焦时自动刷新
			refetchOnReconnect: true, // 网络重新连接时自动刷新
			retry: 3, // 请求失败重试 3 次才算真正失败
			retryDelay: (attemptIndex) =>
				Math.min(1000 * 2 ** attemptIndex, 30000), // 自定义重试间隔
			select: (data) => data.slice(0, 10), // 只取前 10 条，transform 返回新数据
			onSuccess: (data) => {
				console.log("获取成功，数据长度：", data.length);
			},
			onError: (err) => {
				console.error("获取失败：", err);
			},
		}
	);

	if (isLoading) return <div>Loading...</div>;
	if (isError) return <div>Error: {error.message}</div>;

	return (
		<div>
			<h2>Todos 列表：</h2>
			<ul>
				{data.map((todo) => (
					<li key={todo.id}>{todo.title}</li>
				))}
			</ul>
			<button onClick={() => refetch()}>手动刷新</button>
			{isFetching && <span>正在刷新中…</span>}
		</div>
	);
}
```

#### 主要选项说明

- **`queryKey`**
    - 唯一标识一个查询，支持任意可序列化值（数组/字符串/数字等）。
    - 不同参数应使用不同的 key 值来区分（如分页、搜索关键词等）。
- **`queryFn`**
    - 返回一个 Promise（通常是 `fetch` 或 `axios` 请求），且须返回真正的业务数据。
    - 也可以写成异步函数：`async () => { const r = await axios.get(...); return r.data; }`
- **`staleTime`**（毫秒）
    - 数据新鲜周期。在此时间内不会自动 `refetch`，会复用缓存数据。
    - 默认 `0`，即数据立刻变为 “陈旧”，下次组件挂载或窗口焦点切换都会重新拉取。
- **`cacheTime`**（毫秒）
    - 数据被视为 “缓存” 并保留在内存的时长。超过后才会被垃圾回收（GC）。
    - 当某条数据长时间不被任何组件使用，就会被移除，下一次访问需重新 fetch。
- **`enabled`**
    - 布尔值，控制是否自动触发首次请求。设为 `false` 可用于“延迟加载”场景，比如某个条件满足后再去拉取。
    - 若 `enabled: data?.id != null`，则仅在满足条件时发起请求。
- **`refetchOnWindowFocus`** / **`refetchOnReconnect`**
    - 控制窗口重新获得焦点或网络重新连接时，是否自动重新请求最新数据。
    - 这两个选项可以单独开启/关闭，或者写成 `refetchOnWindowFocus: ['online', 'always', 'never']`（v4 支持更灵活配置）。
- **`retry`** / **`retryDelay`**
    - 请求失败时的重试策略。可以设置重试次数，也可以自定义重试延迟函数。
- **`select`**
    - 可对服务器返回的数据做“变形”（映射），只传给组件需要的部分；同时会影响缓存中的数据结构。
- **`onSuccess`** / **`onError`** / **`onSettled`**
    - 请求成功、失败或无论成功失败都会执行的回调，可做日志、埋点、埋 OP 等操作。
- **返回值（部分）**
    - `data`：从 `queryFn` 中返回的最终数据（或 `select` 变形后得到的数据）。
    - `error`：请求失败时的错误对象。
    - `isLoading`：仅在第一次挂载时且未有缓存数据时为 `true`；数据加载完毕变为 `false`。
    - `isFetching`：只要有请求打出去，都为 `true`，即便缓存已有旧数据也一样。
    - `isError`：请求最终失败时为 `true`。
    - `refetch`：手动触发重新加载的方法。

### 3.3 `useMutation`：数据变更

```jsx
import { useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";

function CreateTodo() {
	const queryClient = useQueryClient();

	const { mutate, isLoading, isError, error } = useMutation(
		(newTodo) => axios.post("/api/todos", newTodo).then((res) => res.data),
		{
			onMutate: async (newTodo) => {
				// 在变更正式发到服务器前，先乐观更新缓存
				await queryClient.cancelQueries(["todos"]);
				const previousTodos = queryClient.getQueryData(["todos"]);
				queryClient.setQueryData(["todos"], (old) => [
					...old,
					{ ...newTodo, id: "temp-id" },
				]);
				return { previousTodos };
			},
			onError: (err, newTodo, context) => {
				// 如果出错，回滚到之前的缓存
				queryClient.setQueryData(["todos"], context.previousTodos);
				console.error("创建失败：", err);
			},
			onSettled: () => {
				// 无论成功或失败，都重新拉取最新列表
				queryClient.invalidateQueries(["todos"]);
			},
		}
	);

	const handleCreate = () => {
		mutate({ title: "新待办事项", completed: false });
	};

	if (isLoading) return <div>创建中…</div>;
	if (isError) return <div>创建出错：{error.message}</div>;

	return <button onClick={handleCreate}>新增 Todo</button>;
}
```

#### 主要选项与步骤

1. **`useMutation(mutationFn, options)`**

    - **`mutationFn`**：执行变更（POST/PUT/DELETE）的函数，必须返回 Promise 并最终返回服务器响应。
    - **`options`** 中常见钩子：
        - `onMutate(variables)`：变更发出前的回调，可用于乐观更新（optimistic update），返回一个上下文对象，供 `onError` 回滚使用。
        - `onSuccess(data, variables, context)`：变更成功后回调，可根据服务器返回数据更新缓存。
        - `onError(error, variables, context)`：变更失败时的回调，可回滚或提示错误。
        - `onSettled(data, error, variables, context)`：无论成功或失败都会调用，常用于统一 `invalidateQueries`。

2. **`useQueryClient()`**

    - 获取 `QueryClient` 实例，可用于：
        - `getQueryData(key)`：获取当前缓存数据（乐观更新前可读取旧值）。
        - `setQueryData(key, updater)`：手动更新缓存（可做乐观更新）。
        - `invalidateQueries(key)`：标记该键对应的缓存为“过期”，下一次需要重新拉取。

3. **乐观更新 vs. 服务器返回后更新**

    - **乐观更新**：在 `onMutate` 里先假设变更会成功，先更新前端渲染，再在 `onError` 回滚、`onSettled` 或 `onSuccess` 重新刷新。
    - **服务器返回后更新**：不做乐观更新，只在 `onSuccess` 里 `invalidateQueries` 或 `setQueryData`，等待服务端返回真正数据后，再更新缓存。

### 3.4 其他 API

- **`useInfiniteQuery`**：用于实现“下拉加载更多”或“无限滚动”场景，自动处理分页逻辑。
- **`useQueries`**：一次性并行发起多条查询，返回一个数组形式的查询状态。
- **`useIsFetching` / `useIsMutating`**：全局 loading 状态钩子，获取任意正在请求或变更的数量，可用于显示全局加载指示器。
- **`queryClient.prefetchQuery`**：手动预抓取某条查询，使得用户切换页面时能更快展示。
- **`queryClient.removeQueries`**：手动清除某条或多条缓存。

---

## 4. 典型应用场景

以下示例均采用 React 生态，但同样思路可迁移到 Vue（配合 Vue Query）、Angular（配合 RxJS + Query 库）等场景，或原生 JS 中将数据请求与 UI 更新分离管理。

1. **用户列表分页与搜索**

    - 场景：电商管理后台，需要分页展示用户列表，且支持按姓名或邮箱搜索。
    - 实现思路：
        - `useQuery(['users', { page, keyword }], fetchUsers)`，当 `page` 或 `keyword` 改变时，React Query 自动重拉数据。
        - 配置 `keepPreviousData: true`，在页码切换时保留上一页数据，提升用户体验。
        - 结合 `useInfiniteQuery` 可实现“滚动到底部自动加载下一页”功能。

2. **数据详情与依赖查询**

    - 场景：在产品详情页（`/products/:id`）中，先拉取该产品基本信息，再基于产品 `categoryId` 进一步拉取分类详情；同时渲染用户评论列表。
    - 实现思路：
        1. `const { data: product } = useQuery(['product', id], fetchProductById);`
        2. `const { data: category } = useQuery( ['category', product.categoryId], fetchCategoryById, { enabled: !!product } );`
        3. `const { data: comments } = useQuery(['comments', id], fetchProductComments);`
    - 通过 `enabled: !!product` 确保只有在 `product` 获取到后才触发第二条查询，避免空 ID 时请求无效接口。

3. **表单提交后自动刷新列表**

    - 场景：在待办管理页面，需要通过一个表单新增或编辑待办，提交成功后，要让列表自动更新。
    - 实现思路：
        - 列表组件：`useQuery(['todos'], fetchTodos)`。
        - 表单组件：`useMutation(createOrUpdateTodo, { onSuccess: () => queryClient.invalidateQueries(['todos']) })`。
        - 这样，当表单提交成功后，React Query 会把 `['todos']` 对应的缓存标记过期并重新拉取，列表即时更新。

4. **缓存预取 (Prefetch) 改善用户感知速度**

    - 场景：电商首页上鼠标悬停在某个商品卡片时，提前预取该商品详情，这样用户点进去看详情页时不会有明显加载等待。
    - 实现思路：
        ```jsx
        const queryClient = useQueryClient();
        const handleMouseEnter = (id) => {
        	queryClient.prefetchQuery(["product", id], () =>
        		fetchProductById(id)
        	);
        };
        ```
    - 当用户真正点击时，数据通常已在缓存里，能秒开页面。

5. **全局请求限制与去重**

    - 场景：多个不同组件都需要访问 “当前登录用户信息”，但所有组件都在同一会话周期挂载。
    - 实现：`useQuery(['currentUser'], fetchCurrentUser)` 放在多个地方不会触发多次请求，只有第一次请求成功后，剩余组件都会直接取缓存，无需额外网络开销。

---

## 5. 注意事项与常见错误

1. **忘记包裹 `QueryClientProvider`**

    - 问题：若在组件中直接调用 `useQuery`，却未用 `QueryClientProvider` 包裹，会报 “No QueryClient set” 或类似错误。
    - 解决：确保在应用入口处初始化并包裹。

2. **`queryKey` 不够唯一或可变时机不对**

    - 问题：
        - 如果把整个对象或数组直接写为 `queryKey`（如 `[{ params }]`），但参数在组件每次渲染时都重建，会造成 key 不断变化，导致无法命中缓存、频繁重拉。
    - 解决：
        - 将关键参数拆成基本类型或稳定引用：如 `['todos', pageNum, sortOrder]`，避免每次都传新对象。
        - 对于动态参数，可用 memo 化或在父组件传递固定值。

3. **`staleTime` / `cacheTime` 设定不合理**

    - 问题：
        - 默认 `staleTime = 0`，只要组件重挂载或窗口聚焦都会重新拉取，可能造成过多请求。
        - 若把 `staleTime` 设得过长，又可能导致用户无法及时看到后端最新数据。
    - 解决：
        - 针对业务场景合理设置：一些不经常变动的数据可设较长 `staleTime`；实时性要求高的（如股票价格）可设短或 0。

4. **忘记处理 `enabled: false` 的场景**

    - 问题：设置 `enabled: false` 后，如果条件永远不满足， `data` 永远未定义，导致组件直接 `data.map` 报错。
    - 解决：
        - 在使用前先判断 `if (!data) return null;` 或在 JSX 里加三元判断：`{data?.map(...)}`。

5. **Mutation 后不手动更新或 `invalidateQueries`**

    - 问题：执行完 `useMutation` 后，若不调用 `invalidateQueries` 或者不手动更新缓存（`setQueryData`），界面仍会显示旧数据。
    - 解决：
        - 在 `onSuccess` / `onSettled` 钩子里调用 `queryClient.invalidateQueries(['对应key'])`；
        - 或者用 `queryClient.setQueryData` 精确更新缓存。

6. **在非 React 组件上下文中使用钩子（Hook 规则）**

    - 问题：在普通函数或条件分支里调用 `useQuery`/`useMutation`，会违反 Hook 规则，导致 React 报错。
    - 解决：确保所有 `useQuery`/`useMutation` 都写在组件顶层，条件逻辑通过 `enabled` 控制。

7. **依赖查询（Dependent Queries）写法失误**

    - 问题：如果没有正确使用 `enabled: Boolean(dependencyData)`，会出现 ID 为空时提前触发网络请求，拿不到数据或报错。
    - 解决：
        - 第二个查询的配置写成：
            ```js
            useQuery(["child", parentData.id], fetchChild, {
            	enabled: !!parentData?.id,
            });
            ```

8. **忘记缓存回收（Cache GC）或不清理无用数据**

    - 问题：如果缓存的 key 数量不断增加（如用户频繁搜索不同关键词，每次都存一个 key），内存会渐增。
    - 解决：合理设置 `cacheTime`，不常用的缓存会自动清理；也可以手动 `queryClient.removeQueries`。

9. **`select` 变形操作返回结构不当**

    - 问题：`select` 函数如果返回 `undefined` 或不符合预期，会导致组件拿到 `data` 变成 `undefined`。
    - 解决：在 `select` 中一定要返回合法的值，或在调试时先去掉 `select` 验证数据。

---

以上即为 React Query 的通俗比喻、解决的问题、详细语法与选项、典型应用场景，以及使用时需注意的关键点和常见错误。通过合理配置与使用，能够显著简化 React 前端项目中数据获取与状态管理的复杂度，提高开发效率和代码可维护性。

## 乐观更新（Optimistic Updates）

> **简述：**  
> 乐观更新（Optimistic Update）是一种前端优化策略。假设后端请求通常会成功，不等待后端响应，立即在 UI 中展示更新效果，使用户感受到瞬间响应。若请求成功，则同步后端返回的实际数据；若失败，则回滚至请求前的状态。React Query 使用 `onMutate`、`onSuccess` 和 `onError` 三个回调函数，结合上下文（context）机制，实现安全可靠的乐观更新。

---

**知识树**

1.  **本节重点知识**

    1.  **乐观更新定义及用途**

        - 定义：请求发起时即立即修改本地状态与 UI，而非等待后端响应。
        - 目的：提升用户交互体验，获得瞬时响应效果。

    2.  **React Query 乐观更新实现方式**

        - 核心回调函数：
            - **onMutate**：请求发起前立即执行（用于即时修改缓存）。
            - **onSuccess**：请求成功时执行（替换本地数据为真实数据）。
            - **onError**：请求失败时执行（回滚到更新前状态）。
        - 使用上下文（context）对象传递中间状态。

2.  **核心 API 与回调函数详解**

    1.  **onMutate** 回调函数

        - 执行时机：在请求函数（mutationFn）执行前。
        - 作用：
            - 即时更新 UI（修改 query 缓存）。
            - 创建并返回上下文对象（用于后续回滚）。
        - 参数：`onMutate: (variables: TVariables) => TContext | Promise<TContext>` - `variables`：调用 mutation 时传入的数据（如新增的 todo 项目）。 - 返回 `context`（上下文对象），包含更新前的数据（用于失败时回滚）。

    2.  **onSuccess** 回调函数

        - 执行时机：请求成功、服务器返回数据后。
        - 作用：
            - 更新本地缓存，以服务端返回数据为准。
        - 参数：`onSuccess: (data: TData, variables: TVariables, context?: TContext) => void` - `data`：服务器返回数据（如新增 todo 项，含真实 ID）。 - `variables`：提交请求时传入的数据（乐观 UI 中临时数据）。 - `context`：可选，上下文对象。

    3.  **onError** 回调函数
        - 执行时机：请求失败时触发。
        - 作用：
            - 回滚本地缓存到请求前的状态（利用 context）。
        - 参数：`onError: (error: TError, variables: TVariables, context?: TContext) => void`
            - `error`：请求失败的错误信息。
            - `variables`：调用 mutation 时传入的数据。
            - `context`：包含更新前缓存状态的上下文对象，用于回滚。

3.  **上下文（Context）机制**

    1.  **用途**

        - 保存 mutation 请求前的缓存数据（旧数据）。
        - 传递给 `onError` 回调，用于失败时安全回滚。

    2.  **实现步骤**

        - 定义明确的上下文类型接口：
            ```ts
            interface AddTodoContext {
              previousTodos: ToDo[];
            }
            ```
        - 在 `onMutate` 中返回此上下文：
            ```ts
            onMutate: async (newTodo) => {
              const previousTodos = queryClient.getQueryData<ToDo[]>(['todos']) || [];
              queryClient.setQueryData(['todos'], [newTodo, ...previousTodos]);
              return { previousTodos };
            }
            ```
        - 在 `onError` 中使用此上下文回滚数据：
            ```ts
            onError: (error, newTodo, context) => {
              if (context?.previousTodos) {
                queryClient.setQueryData(['todos'], context.previousTodos);
              }
            }
            ```

4.  **教师示例实现思路与顺序（回忆用）**

    - **步骤一（onMutate 实现）**
        - 创建上下文对象，保存请求前数据；
        - 立即修改缓存，优化用户体验。
    - **步骤二（onSuccess 实现）**
        - 成功时，用真实返回数据替换临时数据（如更新真实 ID）；
        - 使用 `.map()` 方法找到并替换临时数据。
    - **步骤三（onError 实现）**
        - 失败时，通过上下文回滚数据至原状态。

---

**完整代码示例**

```tsx
import React, { useRef } from 'react';
import axios from 'axios';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { ToDo } from './useTodos';

// 接口 URL
const TODOS_URL = 'https://jsonplaceholder.typicode.com/todos';

// Mutation 函数（发送请求到后端）
const addToDoRequest = async (newToDo: ToDo): Promise<ToDo> => {
  const response = await axios.post<ToDo>(TODOS_URL, newToDo);
  return response.data;
};

// 定义上下文接口
interface AddTodoContext {
  previousTodos: ToDo[];
}

export const ToDoForm: React.FC = () => {
  const inputRef = useRef<HTMLInputElement>(null);
  const queryClient = useQueryClient();

  // 使用 useMutation 并定义回调（带上下文类型）
  const addToDoMutation = useMutation<ToDo, Error, ToDo, AddTodoContext>(
    addToDoRequest,
    {
      // 1. onMutate：请求前立即更新 UI
      onMutate: (newToDo) => {
        // 获取更新前缓存
        const previousTodos = queryClient.getQueryData<ToDo[]>(['todos']) || [];

        // 立即更新缓存（乐观更新）
        queryClient.setQueryData(['todos'], [newToDo, ...previousTodos]);

        // 返回上下文对象供失败时回滚
        return { previousTodos };
      },

      // 2. onSuccess：用真实返回数据替换临时数据
      onSuccess: (savedToDo, newToDo) => {
        queryClient.setQueryData<ToDo[]>(['todos'], (todos = []) =>
          todos.map((todo) =>
            todo === newToDo ? savedToDo : todo
          )
        );
      },

      // 3. onError：失败时回滚到更新前状态
      onError: (error, newToDo, context) => {
        if (context?.previousTodos) {
          queryClient.setQueryData(['todos'], context.previousTodos);
        }
        console.error('创建失败：', error.message);
      },
    }
  );

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    const title = inputRef.current?.value.trim();
    if (!title) return;

    const newToDo: ToDo = {
      userId: 1,
      id: Date.now(), // 临时 ID，用于 UI
      title,
      completed: false,
    };

    addToDoMutation.mutate(newToDo);

    if (inputRef.current) {
      inputRef.current.value = '';
    }
  };

  return (
    <>
      {addToDoMutation.error && (
        <div className="alert alert-danger">
          错误：{addToDoMutation.error.message}
        </div>
      )}

      <form onSubmit={handleSubmit}>
        <input
          type="text"
          ref={inputRef}
          placeholder="输入新的待办事项"
        />
        <button type="submit" disabled={addToDoMutation.isLoading}>
          添加
        </button>
      </form>
    </>
  );
};
```

---

**注意事项与总结**

- **务必实现回滚机制**：乐观更新必然伴随失败风险，必须确保能回滚。
- **临时数据与真实数据替换**：必须在 `onSuccess` 中将临时数据替换为后端返回的数据，以保证数据准确性（如真实 ID）。
- **明确上下文类型**：定义明确的上下文接口并传入泛型，保证类型安全。

---

**教师实现步骤快速回忆（编程时参考）**

① 在 `onMutate` 里即时更新 UI → 创建上下文并返回  
② 在 `onSuccess` 中替换临时数据为真实数据  
③ 在 `onError` 中使用上下文数据安全回滚到初始状态  
④ 注意泛型定义明确上下文类型（`useMutation<TData, TError, TVariables, TContext>`）

通过上述详细笔记，即可清晰掌握和回忆 React Query 中乐观更新的实现方法。

## 创建自定义 Mutation Hook（Creating a Custom Mutation Hook）

> **简述：**  
> 当 React 组件同时包含 UI 渲染和数据请求的逻辑时，组件变得复杂且难以维护。为提高代码的模块化、可维护性，我们应将数据管理逻辑抽离为自定义的 hook。这样组件可以专注于 UI 呈现，而 hook 则负责数据逻辑，实现职责分离（separation of concerns）。本节以新增 Todo 为例，展示如何创建并使用自定义 Mutation Hook。

---

**知识树**

1. **本节重点知识**

    1.1 **自定义 Hook 概念与意义**

    - 自定义 Hook：一种抽取组件间共享逻辑的机制，命名需以 `use` 开头。
    - 优势：提高组件的专一性、易于维护、促进代码复用。

        1.2 **组件与 Hook 职责分离**

    - 组件（UI）：处理渲染、交互、状态更新。
    - Hook（数据逻辑）：封装数据请求、缓存管理、乐观更新、错误处理等。

2. **自定义 Mutation Hook 创建步骤**

    2.1 **抽取代码到独立 Hook**

    - 创建新文件：如 `useAddTodo.ts`。
    - 抽取 Mutation 逻辑、`useQueryClient` 和回调函数 (`onMutate`、`onSuccess`、`onError`) 到新 Hook。

        2.2 **明确 Hook 职责（数据管理）**

    - Hook 中避免任何直接操作 UI 的逻辑（如 DOM 操作或 React refs）。
    - UI 更新逻辑（如清空输入框）交由组件执行。

        2.3 **提供回调接口给组件**

    - 在 Hook 中定义回调函数参数，让组件决定何时、如何更新 UI：

    ```ts
    function useAddTodo(onAdd: () => void) { ... }
    ```

    2.4 **返回 Mutation 对象**

    - Hook 返回 Mutation 对象供组件使用：

    ```ts
    const mutation = useMutation(...);
    return mutation;
    ```

    2.5 **定义共享的常量（缓存键）**

    - 避免缓存键重复与拼写错误，将缓存键定义到独立的常量文件：

    ```ts
    // constants.ts
    export const CACHE_KEY_TODOS = ['todos'];
    ```

    2.6 **优化泛型类型与上下文（Context）接口**

    - 将上下文接口定义在 Hook 文件中，明确类型。

3. **代码重构与职责分离的完整过程**

    **教师实现顺序：**

    - 创建 `useAddTodo` Hook 文件。
    - 从组件抽取数据管理逻辑到 Hook。
    - Hook 接受回调函数参数，由组件决定 UI 逻辑。
    - Hook 返回 Mutation 对象给组件调用。
    - 提取公共缓存键到常量文件中。
    - 组织 import，去除冗余导入。

---

**完整代码示例**

### 步骤一：定义缓存键常量

```ts
// constants.ts
export const CACHE_KEY_TODOS = ['todos'];
```

### 步骤二：创建自定义 Hook (`useAddTodo.ts`)

```tsx
// useAddTodo.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import { ToDo } from './useTodos';
import { CACHE_KEY_TODOS } from '../constants';

// 上下文类型
interface AddTodoContext {
  previousTodos: ToDo[];
}

// mutation 函数
const addToDoRequest = async (newToDo: ToDo): Promise<ToDo> => {
  const response = await axios.post<ToDo>('https://jsonplaceholder.typicode.com/todos', newToDo);
  return response.data;
};

// 自定义 Hook
export const useAddTodo = (onAdd: () => void) => {
  const queryClient = useQueryClient();

  const mutation = useMutation<ToDo, Error, ToDo, AddTodoContext>(
    addToDoRequest,
    {
      onMutate: (newToDo) => {
        const previousTodos = queryClient.getQueryData<ToDo[]>(CACHE_KEY_TODOS) || [];

        queryClient.setQueryData(CACHE_KEY_TODOS, [newToDo, ...previousTodos]);

        return { previousTodos };
      },
      onSuccess: (savedToDo, newToDo) => {
        queryClient.setQueryData<ToDo[]>(CACHE_KEY_TODOS, (todos = []) =>
          todos.map((todo) => (todo === newToDo ? savedToDo : todo))
        );

        onAdd(); // 通知组件完成数据更新后的 UI 操作
      },
      onError: (_error, _newToDo, context) => {
        if (context?.previousTodos) {
          queryClient.setQueryData(CACHE_KEY_TODOS, context.previousTodos);
        }
      },
    }
  );

  return mutation;
};
```

### 步骤三：组件调用自定义 Hook (`ToDoForm.tsx`)

```tsx
// ToDoForm.tsx
import React, { useRef } from 'react';
import { useAddTodo } from './hooks/useAddTodo';

export const ToDoForm: React.FC = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  // 调用自定义 Hook 并提供 UI 更新回调
  const addToDoMutation = useAddTodo(() => {
    if (inputRef.current) {
      inputRef.current.value = ''; // UI更新逻辑
    }
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    const title = inputRef.current?.value.trim();
    if (!title) return;

    const newToDo = {
      userId: 1,
      id: Date.now(), // 临时ID
      title,
      completed: false,
    };

    addToDoMutation.mutate(newToDo);
  };

  return (
    <>
      {addToDoMutation.error && (
        <div className="alert alert-danger">
          错误：{addToDoMutation.error.message}
        </div>
      )}

      <form onSubmit={handleSubmit}>
        <input
          type="text"
          ref={inputRef}
          placeholder="输入新的待办事项"
        />
        <button type="submit" disabled={addToDoMutation.isLoading}>
          添加
        </button>
      </form>
    </>
  );
};
```

---

**注意事项与总结**

- **职责明确**：
    - Hook 专注数据管理逻辑（网络请求、缓存更新）。
    - 组件专注 UI 呈现和用户交互逻辑。
- **避免 UI 依赖**：
    - Hook 内部不能直接访问 DOM 或 UI 状态，如 React refs。
    - UI 操作通过回调函数传递给 Hook，更具通用性。
- **使用统一常量管理缓存键**：
    - 防止拼写错误，便于统一维护。

---

**教师实现步骤快速回忆（编程时参考）**

① 创建 `useAddTodo` Hook 文件 → 提取 Mutation 与缓存逻辑  
② Hook 提供 UI 操作回调，组件传入更新 UI 的具体逻辑  
③ Hook 返回 Mutation 对象给组件调用  
④ 提取缓存键到统一常量文件  
⑤ 优化 imports，去除冗余导入

通过以上笔记，可深入理解并熟练使用 React Query 自定义 Hook 模式，有效管理数据逻辑与 UI 分离。

## 创建可复用 API 客户端（Creating a Reusable API Client）

> **简述：**  
> 当前组件的实现存在重复网络请求逻辑的问题，组件或 Hook 内部直接调用 Axios，并手动解析数据，导致代码冗余和维护困难。为解决此问题，我们将抽取请求逻辑到单一的 API 客户端中。通过定义统一的 Axios 实例、明确的泛型接口、以及统一的数据解析机制，实现网络请求的高度复用与维护简化。

---

## 知识树

### 一、本节核心知识点

1. **问题背景与动机**

    - 问题：多个组件或 Hook 中重复实现 Axios 请求逻辑。
    - 动机：消除代码冗余，集中管理 API 调用，降低维护成本。

2. **创建可复用的 API 客户端**

    - **Axios 实例**：
        - `axios.create({ baseURL })` 创建基础 Axios 实例，设置通用请求前缀。
    - **APIClient 类封装请求逻辑**：
        - 封装 `getAll`、`post` 等通用 HTTP 方法。
        - 使用泛型参数保证类型安全与通用性。
    - **使用泛型优化接口定义**：
        - 泛型定义于类级别，确保方法间共享相同类型参数。

3. **APIClient 类方法绑定 this 上下文问题**

    - 问题：方法引用丢失 `this` 上下文导致错误。
    - 解决方案：
        - 使用箭头函数定义类方法，自动绑定 `this` 到类实例。
        - 或使用 `bind(this)` 显式绑定（但相对更啰嗦）。

4. **统一维护 URL 路径（BaseURL 与 Endpoint）**

    - 避免 URL 路径重复定义或拼写错误。
    - 创建 Axios 实例时设置 baseURL，仅需定义具体 endpoint。

---

## 教师示例实现思路与顺序（回忆用）

- 步骤 ①：创建统一 Axios 实例，设置 baseURL。
- 步骤 ②：封装 APIClient 类，抽取 Axios 请求与数据解析逻辑。
- 步骤 ③：泛型定义优化，定义通用数据接口。
- 步骤 ④：解决方法调用时 this 丢失问题，使用箭头函数。
- 步骤 ⑤：更新 Hook 中调用逻辑，改为调用 APIClient 实例方法。

---

## 完整代码示例

### ① 创建 Axios 实例（设置 baseURL）

```ts
// apiClient.ts
import axios from 'axios';

const axiosInstance = axios.create({
  baseURL: 'https://jsonplaceholder.typicode.com',
});
```

---

### ② 封装 APIClient 类（泛型与方法定义）

```ts
// apiClient.ts
export class APIClient<T> {
  constructor(private endpoint: string) {}

  // 获取所有数据
  getAll = () =>
    axiosInstance.get<T[]>(this.endpoint).then(res => res.data);

  // 新增数据
  post = (data: T) =>
    axiosInstance.post<T>(this.endpoint, data).then(res => res.data);
}
```

- **解析：**
    - `getAll` 返回数组类型数据。
    - `post` 接收单个数据项并返回新增的数据。
    - 箭头函数确保 `this` 正确绑定。

---

### ③ 在 Hook 中使用 APIClient（useTodos.ts）

```ts
// useTodos.ts
import { useQuery } from '@tanstack/react-query';
import { APIClient } from './services/apiClient';

// 数据接口
export interface ToDo {
  userId: number;
  id: number;
  title: string;
  completed: boolean;
}

// APIClient 实例化（endpoint: '/todos'）
const todosClient = new APIClient<ToDo>('/todos');

export const useTodos = () =>
  useQuery<ToDo[]>({
    queryKey: ['todos'],
    queryFn: todosClient.getAll, // 方法引用，不调用
  });
```

- **优化点：**
    - 去除 Axios 依赖和重复数据解析逻辑。
    - `queryFn` 直接引用 APIClient 方法。

---

### ④ 在 Mutation Hook 中使用 APIClient（useAddTodo.ts）

```ts
// useAddTodo.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { APIClient } from './services/apiClient';
import { CACHE_KEY_TODOS } from '../constants';
import { ToDo } from './useTodos';

const todosClient = new APIClient<ToDo>('/todos');

interface AddTodoContext {
  previousTodos: ToDo[];
}

export const useAddTodo = (onAdd: () => void) => {
  const queryClient = useQueryClient();

  return useMutation<ToDo, Error, ToDo, AddTodoContext>(
    todosClient.post, // 直接引用 APIClient post 方法
    {
      onMutate: (newTodo) => {
        const previousTodos = queryClient.getQueryData<ToDo[]>(CACHE_KEY_TODOS) || [];
        queryClient.setQueryData(CACHE_KEY_TODOS, [newTodo, ...previousTodos]);
        return { previousTodos };
      },
      onSuccess: (savedTodo, newTodo) => {
        queryClient.setQueryData<ToDo[]>(CACHE_KEY_TODOS, (todos = []) =>
          todos.map(todo => todo === newTodo ? savedTodo : todo)
        );
        onAdd();
      },
      onError: (_error, _newTodo, context) => {
        if (context?.previousTodos) {
          queryClient.setQueryData(CACHE_KEY_TODOS, context.previousTodos);
        }
      },
    }
  );
};
```

- **优势：**
    - Mutation 请求逻辑统一交由 APIClient。
    - 清晰的职责分离，增强维护性与复用性。

---

## 注意事项与总结

- **避免重复**：
    - 统一请求逻辑于 APIClient 类，避免不同组件或 Hook 内重复相同请求代码。
- **泛型接口的重要性**：
    - 通过泛型提高代码通用性和类型安全。
- **this 上下文问题**：
    - 类内方法若直接传递引用（如 `queryFn`），必须使用箭头函数或 bind 显式绑定 this。

---

## 教师实现步骤快速回忆（编程时参考）

① 创建 Axios 实例 (`baseURL`) → 封装 APIClient 类 →  
② 定义通用泛型接口 → 解决方法调用 this 丢失 →  
③ Hook 中使用 APIClient 方法引用，精简组件逻辑。

通过以上完整的实现与细节讲解，可牢固掌握如何创建可复用的 API 客户端，以提升项目的结构清晰度和长期维护性。

## 实现无限加载（Infinite Queries）

> **简述：**  
> 无限加载模式让用户无需手动翻页，通过“加载更多”按钮动态请求下一页数据。React Query 提供 `useInfiniteQuery` 钩子，内置分页参数管理、缓存拼接与结束条件，帮助我们轻松实现不断加载新数据的体验。

---

**知识树**

1. **`useInfiniteQuery` 与分页参数**

    - **用途区别**：
        - `useQuery` 只能一次性获取单页数据；
        - `useInfiniteQuery` 支持多页加载、自动拼接。
    - **`pageParam` 参数**：
        - 钩子在第一次调用时传 `undefined`，可在 `queryFn` 中设默认值（如 `=1`）；
        - 后续调用由 `getNextPageParam` 返回的新页码决定。

2. **查询函数（`queryFn`）实现**

    - 接收解构的 `pageParam`：
        ```ts
        queryFn: ({ pageParam = 1 }) =>
          apiClient.getAll({ params: { ...gameQuery, page: pageParam } })
        ```
    - 将分页页码通过 `params.page` 传给后端；
    - 返回值类型为泛型 `FetchResponse<T>`，包含 `{ count, next, previous, results }`。

3. **下一页参数计算（`getNextPageParam`）**

    - 签名：`(lastPage, allPages) => number | undefined`
    - `lastPage`：最近一次请求返回的分页响应；
    - `allPages`：至今已加载的所有页数据数组；
    - **返回逻辑**：
        - 若 `lastPage.next` 为 truthy（后端指示还有更多页），返回 `allPages.length + 1`；
        - 否则返回 `undefined`，React Query 自动停止后续请求。

4. **组件渲染与“加载更多”交互**

    - **渲染多页数据**：
        ```tsx
        data.pages.map((page, idx) => (
          <React.Fragment key={idx}>
            {page.results.map(game => <GameCard key={game.id} game={game} />)}
          </React.Fragment>
        ))
        ```
    - **解构额外返回值**：
        ```ts
        const { fetchNextPage, hasNextPage, isFetchingNextPage } = useInfiniteQuery(...);
        ```
    - **加载更多按钮**：
        - 条件渲染：`{hasNextPage && <Button ...>...</Button>}`；
        - 动态文案：加载中时显示“加载中…”，否则“加载更多”；
        - 点击触发：`onClick={() => fetchNextPage()}`。
    - **布局优化**：使用容器（如 `Box`）统一设置 `padding`，为按钮添加 `margin-top`。

---

**代码示例**

1. **自定义无限查询 Hook**

    ```ts
    // hooks/useInfiniteGames.ts
    import { useInfiniteQuery } from '@tanstack/react-query';
    import apiClient, { FetchResponse } from '../services/apiClient';
    import { Game } from '../data/games';

    export function useInfiniteGames(gameQuery: Record<string, unknown>) {
      return useInfiniteQuery<FetchResponse<Game>, Error>({
        queryKey: ['games', gameQuery],
        // ① queryFn 接收 pageParam，默认 1
        queryFn: ({ pageParam = 1 }) =>
          apiClient.getAll({
            params: { ...gameQuery, page: pageParam },
          }),
        // ② getNextPageParam 计算下一页或停止
        getNextPageParam: (lastPage, allPages) =>
          lastPage.next ? allPages.length + 1 : undefined,
      });
    }
    ```

2. **组件中渲染与加载更多**

    ```tsx
    // components/GameGrid.tsx
    import React from 'react';
    import { Box, Button } from '@chakra-ui/react';
    import { useInfiniteGames } from '../hooks/useInfiniteGames';
    import { GameCard } from './GameCard';

    interface Props {
      gameQuery: Record<string, unknown>;
    }

    export const GameGrid: React.FC<Props> = ({ gameQuery }) => {
      const {
        data,
        isLoading,
        isError,
        error,
        fetchNextPage,
        hasNextPage,
        isFetchingNextPage,
      } = useInfiniteGames(gameQuery);

      if (isLoading) return <p>加载中…</p>;
      if (isError)   return <p>错误：{error.message}</p>;

      return (
        <Box p="4">
          {/* 渲染所有已加载页的游戏卡片 */}
          {data?.pages.map((page, pageIndex) => (
            <React.Fragment key={pageIndex}>
              {page.results.map(game => (
                <GameCard key={game.id} game={game} />
              ))}
            </React.Fragment>
          ))}

          {/* 加载更多按钮 */}
          {hasNextPage && (
            <Button
              mt="4"
              onClick={() => fetchNextPage()}
              isLoading={isFetchingNextPage}
            >
              {isFetchingNextPage ? '加载中…' : '加载更多'}
            </Button>
          )}
        </Box>
      );
    };
    ```

---

通过以上步骤，你可以在 React Query 项目中轻松实现无限加载，提供“加载更多”交互，并利用 `useInfiniteQuery` 的分页管理与缓存拼接能力，优化用户体验并保持代码整洁。

## 实现无限滚动（Implementing Infinite Scroll）

> **简述：**  
> 无限滚动让用户在浏览列表时，无需手动点击“加载更多”，页面滚动到底部时自动请求下一页数据。结合 `useInfiniteQuery` 与第三方库 `react-infinite-scroll-component`，我们只需配置加载项统计、判断是否还有更多、以及触发加载回调，即可轻松实现滚动加载的用户体验。

---

**知识树**

1. **安装与引入 InfiniteScroll 组件**

    - 安装依赖：`npm install react-infinite-scroll-component`
    - 在组件中 `import InfiniteScroll from 'react-infinite-scroll-component'`

2. **统计已加载条目数（`dataLength`）**

    - 使用 `data.pages.reduce((total, page) ⇒ total + page.results.length, 0)`
    - 初/.,始未定义时返回 `0`（例如 `const count = data?.pages.reduce(...) ?? 0`）

3. **判断是否还有更多（`hasMore`）**

    - 来源于 `useInfiniteQuery` 返回的 `hasNextPage`
    - 使用双重否定 `!!hasNextPage` 确保为布尔值

4. **触发下一页加载（`next` 回调）**

    - 传入 `() ⇒ fetchNextPage()`，调用 React Query 的 `fetchNextPage` 方法

5. **加载指示器（`loader`）**

    - 在 `loader` 属性中渲染一个 `Spinner` 或其他加载动画
    - 用户滚动到底部时会显示该指示器

6. **布局与清理**

    - 用 `SimpleGrid`（或其他布局）包裹所有页数据，无需再保留“加载更多”按钮
    - 将原先的 `Box` 容器的 `padding` 直接应用到 `SimpleGrid`

---

**代码示例**

```tsx
import React from 'react';
import InfiniteScroll from 'react-infinite-scroll-component';
import { SimpleGrid, Spinner } from '@chakra-ui/react';
import { useInfiniteGames } from '../hooks/useInfiniteGames';
import { GameCard } from './GameCard';

interface Props {
  gameQuery: Record<string, unknown>;
}

export const GameGrid: React.FC<Props> = ({ gameQuery }) => {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    isError,
    error,
  } = useInfiniteGames(gameQuery);

  if (isLoading) return <Spinner />;
  if (isError)   return <p>错误：{error.message}</p>;

  // 1. 计算已加载游戏总数
  const fetchedGamesCount =
    data?.pages.reduce((total, page) => total + page.results.length, 0) ?? 0;

  return (
    <InfiniteScroll
      dataLength={fetchedGamesCount}        // 已渲染项目数
      next={() => fetchNextPage()}          // 加载下一页
      hasMore={!!hasNextPage}               // 是否还有更多
      loader={<Spinner mt="4" />}           // 加载时显示
    >
      {/* 2. 将 padding 应用到网格，不再使用外层 Box */}
      <SimpleGrid columns={{ sm: 1, md: 2, lg: 3 }} spacing="4" p="4">
        {data.pages.map((page, pageIndex) => (
          <React.Fragment key={pageIndex}>
            {page.results.map((game) => (
              <GameCard key={game.id} game={game} />
            ))}
          </React.Fragment>
        ))}
      </SimpleGrid>
    </InfiniteScroll>
  );
};
```

---

通过以上步骤，你即可用最少的改动将“加载更多”按钮升级为**无限滚动**，为用户提供更流畅的浏览体验，并保持代码简洁可维护。
