# MySQL 主从复制

## 配置

三台服务器
服务器 A：47.111.2.191
服务器 B：114.215.192.250
服务器 C：47.97.225.83

## 步骤

### 设置安全组/防火墙

各服务器开放端口（默认 3306）

### 启动容器

服务器 A（主库 Master）

```sh
# 下面这两个参数是主从复制必须有的：
# --server-id=1         # 唯一编号
# --log-bin=mysql-bin   # 开启binlog
# --binlog-do-db=testdb # 只同步testdb数据库（一般不写，默认全同步）
docker run -d \
  --name mysql-master \
  -e MYSQL_ROOT_PASSWORD=myPassword! \
  -e MYSQL_REPLICATION_USER=repl \
  -e MYSQL_REPLICATION_PASSWORD=myPassword! \
  -p 3306:3306 \
  mysql:8.0 \
  --default-authentication-plugin=mysql_native_password \
  --server-id=1 \
  --log-bin=mysql-bin

```

服务器 B（从库 Slave1）

```sh
docker run -d \
  --name mysql-slave1 \
  -e MYSQL_ROOT_PASSWORD=myPassword! \
  -p 3306:3306 \
  mysql:8.0 \
  --default-authentication-plugin=mysql_native_password \
  --server-id=2
```

服务器 C（从库 Slave2）

```sh
docker run -d \
  --name mysql-slave2 \
  -e MYSQL_ROOT_PASSWORD=myPassword! \
  -p 3306:3306 \
  mysql:8.0 \
  --default-authentication-plugin=mysql_native_password \
  --server-id=3
```

### 主库授权复制用户（在主库执行）

```sql
-- 登录主库
docker exec -it mysql-master mysql -uroot -pmyPassword!

-- 创建复制账号（如已通过环境变量创建，可跳过）
CREATE USER 'repl'@'%' IDENTIFIED BY 'myPassword!';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;
```

### 查看主库 binlog 信息

```sql
SHOW MASTER STATUS;
-- 输出例子：
-- File: mysql-bin.000003  Position: 826
```

### 配置从库（Slave）

Slave1 和 Slave2 都执行：

```sql
-- 登录从库
docker exec -it mysql-slave1 mysql -uroot -pmyPassword!
-- 或
docker exec -it mysql-slave2 mysql -uroot -pmyPassword!

-- 执行主从复制配置
CHANGE MASTER TO
  MASTER_HOST='47.111.2.191',
  MASTER_USER='repl',
  MASTER_PASSWORD='myPassword!',
  MASTER_LOG_FILE='mysql-bin.000003',   -- 填主库上一步查到的
  MASTER_LOG_POS=826;                   -- 填主库上一步查到的
START SLAVE;
```

### 检查主从状态

Slave1 和 Slave2 都执行：

```sql
SHOW SLAVE STATUS\G
```

输出中有：

- `Slave_IO_Running: Yes`
- `Slave_SQL_Running: Yes`
    都为 Yes 即主从同步成功！

### 测试主从同步

在主库创建数据库/表/插入数据，几秒后从库查询能看到数据即为同步正常。

主库执行

```sql
-- 登录主库
docker exec -it mysql-master mysql -uroot -pmyPassword!

-- 主库执行
-- 创建数据库 testDB
CREATE DATABASE testDB;
-- 创建表 testTB
USE testDB;
CREATE TABLE testTB (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    age INT
);

-- 插入一条数据
INSERT INTO testTB (name, age) VALUES ('Alice', 23);
-- 查询
SELECT * FROM testTB;
```

从库执行

```sql
-- 登录从库
docker exec -it mysql-slave1 mysql -uroot -pmyPassword!
-- 或
docker exec -it mysql-slave2 mysql -uroot -pmyPassword!

-- 几秒后查询语句从库
USE testDB;
SELECT * FROM testTB;
```

主库执行

```sql
-- 测试结束主库删除数据库
DROP TABLE testTB;
DROP DATABASE testDB;
-- 查询
SELECT * FROM testTB;
```

从库执行

```sql
-- 几秒后查询语句从库
SELECT * FROM testTB;
```

# 本地模拟 MySQL 主从复制

## 配置

本地 Docker，分端口 3006，3007，3008

## 步骤

### 启动容器

服务器 A（主库 Master）

```sh
# 下面这两个参数是主从复制必须有的：
# --server-id=1         # 唯一编号
# --log-bin=mysql-bin   # 开启binlog

# --name                          容器名：mysql-master
# -p 3306:3306                    宿主机 3306 端口映射到容器 3306
# -v $PWD/mysql-master-data       数据持久化到本地目录
# -e MYSQL_ROOT_PASSWORD          初始化 root 密码
# -e MYSQL_DATABASE               启动时创建 testdb 数据库（可以不写）
# --server-id=1                   唯一编号
# --log-bin=mysql-bin             开启MySQL的二进制日志功能，并指定日志文件前缀为 mysql-bin
# --binlog_format                 设置 binlog 的记录格式为行级日志
# --default-authentication-plugin 兼容老客户端认证方式（MySQL 8+ 推荐）
# --max_allowed_packet            默认为 16M，可以手动调整
# --binlog-do-db=testdb           # 只同步testdb数据库（一般不写，默认全同步）

docker run -d \
  --name mysql-master \
  -p 3306:3306 \
  -v $PWD/mysql-replication/mysql-master-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=myPassword! \
  mysql:8.0 \
  --server-id=1 \
  --log-bin=mysql-bin \
  --binlog_format=ROW \
  --default-authentication-plugin=mysql_native_password
```

服务器 B（从库 Slave1）

```sh
docker run -d \
  --name mysql-slave1 \
  -p 3307:3306 \
  -v $PWD/mysql-replication/mysql-slave1-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=myPassword! \
  mysql:8.0 \
  --server-id=2 \
  --default-authentication-plugin=mysql_native_password
```

服务器 C（从库 Slave2）

```sh
docker run -d \
  --name mysql-slave2 \
  -p 3308:3306 \
  -v $PWD/mysql-replication/mysql-slave2-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=myPassword! \
  mysql:8.0 \
  --server-id=3 \
  --default-authentication-plugin=mysql_native_password
```

### 主库授权复制用户（在主库执行）

```sql
-- 登录主库
docker exec -it mysql-master mysql -uroot -pmyPassword!

-- 创建复制账号（如已通过环境变量创建，可跳过）
CREATE USER 'repl'@'%' IDENTIFIED BY 'myPassword!';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;
```

### 查看主库 binlog 信息

```sql
SHOW MASTER STATUS;
-- 输出例子：
-- File: mysql-bin.000003  Position: 827
```

### 配置从库（Slave）

Slave1 和 Slave2 都执行：

```sql
-- 登录从库
docker exec -it mysql-slave1 mysql -uroot -pmyPassword!
-- 或
docker exec -it mysql-slave2 mysql -uroot -pmyPassword!

-- 执行主从复制配置，这里host.docker.internal是指主机（Mac/Windows），Linux为172.17.0.1
CHANGE MASTER TO
  MASTER_HOST='host.docker.internal',
  MASTER_USER='repl',
  MASTER_PASSWORD='myPassword!',
  MASTER_LOG_FILE='mysql-bin.000003',
  MASTER_LOG_POS=827;
START SLAVE;

-- 出错考虑执行这两步
-- STOP SLAVE;
-- RESET SLAVE ALL;
```

### 检查主从状态

Slave1 和 Slave2 都执行：

```sql
SHOW SLAVE STATUS\G
```

输出中有：

- `Slave_IO_Running: Yes`
- `Slave_SQL_Running: Yes`
    都为 Yes 即主从同步成功！

### 测试主从同步

在主库创建数据库/表/插入数据，几秒后从库查询能看到数据即为同步正常。

主库执行

```sql
-- 登录主库
docker exec -it mysql-master mysql -uroot -pmyPassword!

-- 主库执行
-- 创建数据库 testDB
CREATE DATABASE testDB;
-- 创建表 testTB
USE testDB;
CREATE TABLE testTB (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    age INT
);

-- 插入一条数据
INSERT INTO testTB (name, age) VALUES ('Alice', 23);
-- 查询
SELECT * FROM testTB;
```

从库执行

```sql
-- 登录从库
docker exec -it mysql-slave1 mysql -uroot -pmyPassword!
-- 或
docker exec -it mysql-slave2 mysql -uroot -pmyPassword!

-- 几秒后查询语句从库
USE testDB;
SELECT * FROM testTB;
```

主库执行

```sql
-- 登录主库
docker exec -it mysql-master mysql -uroot -pmyPassword!
-- 测试结束主库删除数据库
DROP TABLE testTB;
DROP DATABASE testDB;
-- 查询
USE testDB;
SELECT * FROM testTB;
```

从库执行

```sql
-- 登录从库
docker exec -it mysql-slave1 mysql -uroot -pmyPassword!
-- 或
docker exec -it mysql-slave2 mysql -uroot -pmyPassword!

-- 几秒后查询语句从库
USE testDB;
SELECT * FROM testTB;
```

# Redis Cluster

## 配置

三台服务器
服务器 A：47.111.2.191
服务器 B：114.215.192.250
服务器 C：47.97.225.83

## 步骤

### 设置安全组/防火墙

- 开放 6379、6380、16379、16380
- 补充
    - 6379-6385（每节点监听端口，集群测试建议每台至少 2 个端口）
    - 16379-16385（集群节点间通信端口 = 主端口+10000）

### 三台服务器都拉取 Redis 镜像

```sh
docker pull redis:7.2
```

### 启动 Redis 容器（每台服务器起 2 个节点，方便集群演示/高可用）

服务器 A (47.111.2.191)

```sh
# 节点1
docker run -d --name redis-6379 \
  -p 6379:6379 -p 16379:16379 \
  redis:7.2 \
  redis-server --port 6379 --cluster-enabled yes --cluster-config-file nodes-6379.conf --cluster-node-timeout 5000 --appendonly yes --cluster-announce-ip 47.111.2.191 --cluster-announce-port 6379 --cluster-announce-bus-port 16379

# 节点2
docker run -d --name redis-6380 \
  -p 6380:6380 -p 16380:16380 \
  redis:7.2 \
  redis-server --port 6380 --cluster-enabled yes --cluster-config-file nodes-6380.conf --cluster-node-timeout 5000 --appendonly yes --cluster-announce-ip 47.111.2.191 --cluster-announce-port 6380 --cluster-announce-bus-port 16380
```

服务器 B (114.215.192.250)

```sh
docker run -d --name redis-6379 \
  -p 6379:6379 -p 16379:16379 \
  redis:7.2 \
  redis-server --port 6379 --cluster-enabled yes --cluster-config-file nodes-6379.conf --cluster-node-timeout 5000 --appendonly yes --cluster-announce-ip 114.215.192.250 --cluster-announce-port 6379 --cluster-announce-bus-port 16379

docker run -d --name redis-6380 \
  -p 6380:6380 -p 16380:16380 \
  redis:7.2 \
  redis-server --port 6380 --cluster-enabled yes --cluster-config-file nodes-6380.conf --cluster-node-timeout 5000 --appendonly yes --cluster-announce-ip 114.215.192.250 --cluster-announce-port 6380 --cluster-announce-bus-port 16380
```

服务器 C (47.97.225.83)

```sh
docker run -d --name redis-6379 \
  -p 6379:6379 -p 16379:16379 \
  redis:7.2 \
  redis-server --port 6379 --cluster-enabled yes --cluster-config-file nodes-6379.conf --cluster-node-timeout 5000 --appendonly yes --cluster-announce-ip 47.97.225.83 --cluster-announce-port 6379 --cluster-announce-bus-port 16379

docker run -d --name redis-6380 \
  -p 6380:6380 -p 16380:16380 \
  redis:7.2 \
  redis-server --port 6380 --cluster-enabled yes --cluster-config-file nodes-6380.conf --cluster-node-timeout 5000 --appendonly yes --cluster-announce-ip 47.97.225.83 --cluster-announce-port 6380 --cluster-announce-bus-port 16380
```

### 创建集群（任选一台机器操作）

需要提前安装 redis-cli 工具，建议用 docker 自带

假设所有实例都启动后，任选一台服务器执行，按提示输入 yes 即可。这样会自动在 6 个节点间分配 3 主 3 从。

```sh
docker run -it --rm redis:7.2 \
  redis-cli --cluster create \
  47.111.2.191:6379 47.111.2.191:6380 \
  114.215.192.250:6379 114.215.192.250:6380 \
  47.97.225.83:6379 47.97.225.83:6380 \
  --cluster-replicas 1 #  意思是每个主节点有1个从节点（容错）
```

### 验证集群状态

任选一节点：

```sh
docker exec -it redis-6379 redis-cli -c -p 6379
# 进入后，执行
cluster info
cluster nodes
```

出现 cluster_state:ok 即表示集群组建成功！

### Spring Boot 集群配置（YAML 例子）

```yml
spring:
  redis:
    cluster:
      nodes:
        - 47.111.2.191:6379
        - 114.215.192.250:6379
        - 47.97.225.83:6379
        - 47.111.2.191:6380
        - 114.215.192.250:6380
        - 47.97.225.83:6380
    password: 你的密码（如未设置可不写）
```

# 本地模拟 Redis Cluster

### 方案选择

原计划通过 docker 部署 6 个 redis 节点实现，但事实是，在非 Linux 环境下，docker 如果通过 127.1.1 部署 redis，redis 之间无法通信，而通过网络部署 redis，springboot 直接启动时无法访问

使用 cluster，镜像更友好，如`grokzen/redis-cluster:7.2.0`，但是不兼容 mac 的 arm 架构，另有其他 cluster 镜像，但是都需要通过 k8s，或者 Dockerfile 来实现，无法达到本地直接启动项目就可以跑的效果

最终采用本地部署，先通过 brew

```sh
brew install redis
```

### 创建目录和 redis.conf

```sh
for port in {6379..6384}; do
  mkdir -p "$(pwd)/redis-cluster/$port"
  cat > "$(pwd)/redis-cluster/$port/redis.conf" <<EOF
port $port
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
dir $(pwd)/redis-cluster/$port
daemonize yes
EOF
done
```

### 启动 6 个 Redis 实例

```sh
for port in {6379..6384}; do
  redis-server "$(pwd)/redis-cluster/$port/redis.conf"
done
```

### 组建集群

```sh
redis-cli --cluster create \
  127.0.0.1:6379 \
  127.0.0.1:6380 \
  127.0.0.1:6381 \
  127.0.0.1:6382 \
  127.0.0.1:6383 \
  127.0.0.1:6384 \
  --cluster-replicas 1
```

- 此时会让你输入 yes，回车即可自动分配 3 主 3 从。

### 验证集群

```sh
redis-cli -c -p 6379
cluster info
cluster nodes
```

### 其他

关闭全部 Redis 节点

```sh
for port in {6379..6384}; do
  redis-cli -p $port shutdown
done
```
